<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[hSATAC]]></title>
  <link href="http://blog.hsatac.net/atom.xml" rel="self"/>
  <link href="http://blog.hsatac.net/"/>
  <updated>2013-02-19T17:57:21+08:00</updated>
  <id>http://blog.hsatac.net/</id>
  <author>
    <name><![CDATA[hSATAC]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用 Puppet 快速佈署 Archlinux]]></title>
    <link href="http://blog.hsatac.net/2013/02/bootstrap-archlinux-with-puppet/"/>
    <updated>2013-02-19T17:51:00+08:00</updated>
    <id>http://blog.hsatac.net/2013/02/bootstrap-archlinux-with-puppet</id>
    <content type="html"><![CDATA[<p>筆記一下安裝步驟&#8230;。</p>

<h2>Install Archlinux</h2>

<p>由於 Archlinux 本身沒有提供方便的安裝模式、因此我們使用方便的第三方快速安裝 script，安裝完成後再使用 puppet bootstrap 環境</p>

<ul>
<li>放入 CD 選擇 x64_64 開機</li>
<li>執行 <code>curl hsatac.net/getaui | sh</code></li>
<li>進入 helmuthdu-aui-xxxx 目錄</li>
<li>執行 <code>./aui --ais</code> 進入安裝程式</li>
<li>輸入 1-14 執行全部安裝步驟</li>
</ul>


<p>ps. 如遇特定機種無法使用 grub2 可改用 syslinux bootloader</p>

<h2>Reboot</h2>

<p>安裝完成重開機後後首先設定讓網路能通
可參考<a href="https://wiki.archlinux.org/index.php/Network_Configuration">官方wiki</a></p>

<p>如欲使用 dhcp 可執行 <code>systemctl start dhcpcd</code>
<code>systemctl enable dhcpcd</code> 開機自動執行</p>

<ul>
<li>回到 helmuthdu-aui-xxx 目錄</li>
<li>執行 <code>./aui</code> 繼續安裝</li>
<li>新增使用者步驟必須執行，因後續步驟需用 sudo</li>
<li>AUR helper 選擇 yaourt
(Yaourt 和 packer 大同小異，但因 puppet 使用 yaourt 所以改用。)</li>
<li>後面的 setup 可跳過，或者裝 Basic Setup 即可，這邊都是 桌面環境相關</li>
<li>設定 /etc/resolv.conf</li>
</ul>


<h2>使用 puppet</h2>

<p>puppet 可使用 master-agent 架構或者單機(solo) 安裝，詳見 puppet wiki</p>

<ul>
<li><code>yaourt puppet</code> 安裝 puppet</li>
<li>在 /etc/hosts 設定 puppet master hostname 並在 /etc/puppet/puppet.conf [agent] 區塊設定 <code>server = xxx</code> (hostname 要跟 master hostname 一樣不然憑證不會過)</li>
<li>run <code>puppet agent --test</code> 會出現沒有憑證訊息</li>
<li>回到 puppet master 執行 <code>puppet cert list</code> 會看到待簽署的憑證</li>
<li>執行 <code>puppet cert sign [hostname]</code> 簽署</li>
<li>記得在 master 的 /etc/puppet/manifests/site.pp 設定新的 node 定義</li>
<li>回到 agent 執行 <code>puppet agent --test</code> 進行安裝</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RWBY]]></title>
    <link href="http://blog.hsatac.net/2013/02/rwby/"/>
    <updated>2013-02-15T17:54:00+08:00</updated>
    <id>http://blog.hsatac.net/2013/02/rwby</id>
    <content type="html"><![CDATA[<p>RWBY 第二部預告片 &#8220;White&#8221; 終於推出！</p>

<p>之前看完第一部 &#8220;Red&#8221; 時還沒有特別被萌到，只覺得創意、畫面和音樂都還不錯。不過這次看完 &#8220;White&#8221; 以後整個點都被打到啦！直接去 itunes 收了這兩首 OST…</p>

<p>下一部 &#8220;Black&#8221; 預計在 2013.07 發佈，這樣算來本體推出都要 2014 啦！實在是很大一個坑&#8230;</p>

<iframe width="560" height="315" src="http://www.youtube.com/embed/Vt9vl8iAN5Q" frameborder="0" allowfullscreen></iframe>


<!--more-->




<blockquote><p>Mirror, tell me something.<br/>Tell me who&#8217;s the loneliest of all.</p><p>Mirror, tell me something.<br/>Tell me who&#8217;s the loneliest of all.</p><p>Mirror, locked inside of me.<br/>Tell me can a heart be turned to stone?</p><p>Mirror mirror what&#8217;s behind you?<br/>Save me from the things I see!<br/>I can keep it from the world,<br/>why wont you let me hide from me?</p><p>Mirror, mirror,<br/>tell me something.<br/>Who&#8217;s the loneliest of all?</p><p>I am the loneliest of all.</p></blockquote>


<p>第一部 &#8220;Red&#8221;</p>

<iframe width="560" height="315" src="http://www.youtube.com/embed/pYW2GmHB5xs" frameborder="0" allowfullscreen></iframe>




<blockquote><p>Red like roses fills my dreams and brings me to the place you rest<br/>White is cold and always yearning burdened by a royal test<br/>Black the beast descends from shadows<br/>Yellow beauty burns gold</p></blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[追蹤 Rubygems require 緩慢紀錄]]></title>
    <link href="http://blog.hsatac.net/2013/01/trace-rubygems-require-slow/"/>
    <updated>2013-01-30T10:18:00+08:00</updated>
    <id>http://blog.hsatac.net/2013/01/trace-rubygems-require-slow</id>
    <content type="html"><![CDATA[<p>昨天灌了一台新的機器，正準備用 <a href="http://puppetlabs.com">puppet</a> bootstrap 時卻發現他的 puppet 執行的非常緩慢。追蹤解決問題的過程十分有趣，在這邊紀錄一下。</p>

<p>由於 puppet 執行檔本身是一隻 ruby script，於是開啟了 irb -d 使用 DEBUG 模式直接執行看看該 script 的內容，看看能否看出問題在哪。</p>

<!--more-->


<p>結果是慢在 <code>require 'puppet'</code> 這裡。想說是不是 gempath 的問題，先用 gem env 看一下設定和環境變數，感覺一切正常。在使用 gem 指令的過程中，發現 <code>gem help commands</code> 這個指令也異常緩慢，而且和 puppet 慢的速度感覺是一樣的。使用 <code>time gem help commands</code> 和 <code>time puppet</code>
測量，果然兩邊都是慢 20 秒，感覺之間可能有某些關聯。</p>

<p>一度懷疑是硬碟壞軌，使用 <code>smartctl</code> 顯示硬碟狀況良好，又開始懷疑是 Ruby 1.9.3-p374 的 bug。但是上網搜尋沒有這樣的狀況，拿另一台舊的機器升級 Ruby 1.9.3-p374 也沒有這樣的狀況。看來是機器本身的問題。</p>

<p><code>ruby -d</code> 和 <code>irb -d</code> 都無法提供有用的資訊，只能看出在某個階段會卡住很久，只能往更低階的方向走。</p>

<p>先使用 <code>ltrace</code> 來觀察：</p>

<pre>
# ltrace -r ruby `which gem` help commands
  0.000000 __libc_start_main(0x400860, 4, 0x7fff767d5ce8, 0x4009a0 <unfinished ...>
  0.000301 setlocale(LC_CTYPE, "")                                                                                                            = "en_US.UTF-8"
  0.000577 ruby_sysinit(0x7fff767d5bec, 0x7fff767d5be0, 1, 1)                                                                                 = 0
  0.000319 ruby_init_stack(0x7fff767d5bf8, 0x7fff767d5b30, 0x7fff767d5b30, -1)                                                                = 0
  0.000759 ruby_init(0x7febf8, 0xffffffff, 0, 0)                                                                                              = 0x876f20
  0.005726 ruby_options(4, 0x7fff767d5ce8, 0x877520, 0x7f3c31b59640)                                                                          = 0xad4800
  0.025221 ruby_run_node(0xad4800, 0x7fff767d6fea, 0x877520, 0xad9560
  20.511227 +++ exited (status 0) +++
</pre>


<p>只能看出卡在 ruby_run_node 這邊，再翻出 <code>strace</code> 試試：</p>

<pre>
# strace -rT ruby `which gem` help commands
     0.000051 open("/usr/lib/libresolv.so.2", O_RDONLY|O_CLOEXEC) = 5 <0.000012>
     0.000049 read(5, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\220:\0\0\0\0\0\0"..., 832) = 832 <0.000008>
     0.000049 fstat(5, {st_mode=S_IFREG|0755, st_size=84840, ...}) = 0 <0.000007>
     0.000049 mmap(NULL, 2189960, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 5, 0) = 0x7fd97dd1e000 <0.000009>
     0.000047 mprotect(0x7fd97dd31000, 2097152, PROT_NONE) = 0 <0.000012>
     0.000048 mmap(0x7fd97df31000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 5, 0x13000) = 0x7fd97df31000 <0.000011>
     0.000054 mmap(0x7fd97df33000, 6792, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7fd97df33000 <0.000010>
     0.000053 close(5)                  = 0 <0.000007>
     0.000104 mprotect(0x7fd97df31000, 4096, PROT_READ) = 0 <0.000011>
     0.000059 mprotect(0x7fd97e139000, 4096, PROT_READ) = 0 <0.000009>
     0.000048 munmap(0x7fd98213a000, 24363) = 0 <0.000011>
     0.000100 socket(PF_INET, SOCK_DGRAM|SOCK_NONBLOCK, IPPROTO_IP) = 5 <0.000013>
     0.000051 connect(5, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("192.168.79.161")}, 16) = 0 <0.000017>
     0.000073 poll([{fd=5, events=POLLOUT}], 1, 0) = 1 ([{fd=5, revents=POLLOUT}]) <0.000009>
     0.000058 sendmmsg(5, {{{msg_name(0)=NULL, msg_iov(1)=[{"\362\36\1\0\0\1\0\0\0\0\0\0\5devm3\0\0\1\0\1", 23}], msg_controllen=0, msg_flags=MSG_EOR|MSG_TRUNC|MSG_DONTWAIT|MSG_FIN|MSG_SYN|MSG_NOSIGNAL|MSG_MORE|MSG_WAITFORONE|0x13a0000}, 23}, {{msg_name(0)=NULL, msg_iov(1)=[{":O\1\0\0\1\0\0\0\0\0\0\5devm3\0\0\34\0\1", 23}], msg_controllen=0, msg_flags=MSG_PROXY|MSG_EOR|MSG_WAITALL|MSG_TRUNC|MSG_DONTWAIT|MSG_SYN|MSG_RST|MSG_WAITFORONE|0x1120000}, 23}}, 2, MSG_NOSIGNAL) = 2 <0.000020>
     0.000081 poll([{fd=5, events=POLLIN}], 1, 5000) = 0 (Timeout) <5.004974>
     5.005030 poll([{fd=5, events=POLLOUT}], 1, 0) = 1 ([{fd=5, revents=POLLOUT}]) <0.000008>
     0.000051 sendmmsg(5, {{{msg_name(0)=NULL, msg_iov(1)=[{"\362\36\1\0\0\1\0\0\0\0\0\0\5devm3\0\0\1\0\1", 23}], msg_controllen=0, msg_flags=MSG_EOR|MSG_TRUNC|MSG_DONTWAIT|MSG_FIN|MSG_SYN|MSG_NOSIGNAL|MSG_MORE|MSG_WAITFORONE|0x13a0000}, 23}, {{msg_name(0)=NULL, msg_iov(1)=[{":O\1\0\0\1\0\0\0\0\0\0\5devm3\0\0\34\0\1", 23}], msg_controllen=0, msg_flags=MSG_PROXY|MSG_EOR|MSG_WAITALL|MSG_TRUNC|MSG_DONTWAIT|MSG_SYN|MSG_RST|MSG_WAITFORONE|0x1120000}, 23}}, 2, MSG_NOSIGNAL) = 2 <0.000015>
     0.000075 poll([{fd=5, events=POLLIN}], 1, 5000^CProcess 7498 detached
 <detached ...>
</pre>


<p>可以很明顯看出是往 192.168.79.161:53 問 devm3 ，結果 timeout 了四次，一次五秒剛好 20 秒。</p>

<p>兇手已經呼之欲出了，就是我 =皿=</p>

<p>當時幫這台新機器改了 hostname 以後，忘記修改 /etc/hosts ，導致他自己不認得自己的 hostname。當然那個會 timeout 的 DNS 也是有問題，不過那是關於 djbdns 的另一個故事了&#8230;。</p>

<p>最後將 /etc/hosts 改回來就完全正常了。可喜可賀。最難抓的 bug 果然都是最愚蠢的&#8230;。</p>

<p>在這邊要感謝 <a href="http://www.tenlong.com.tw/items/9862765674?item_id=481936">Debug Hacks 除錯駭客－極致除錯的技巧與工具</a> 一書的譯者，事實證明寫 scripting language 也是要會一些基礎 debug 技巧的！推薦各位購買這本書。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RubyConf.tw 2012 流水帳]]></title>
    <link href="http://blog.hsatac.net/2012/12/ruby-conf-taiwan-2012/"/>
    <updated>2012-12-09T13:04:00+08:00</updated>
    <id>http://blog.hsatac.net/2012/12/ruby-conf-taiwan-2012</id>
    <content type="html"><![CDATA[<p>今年的 Ruby Conf Taiwan 2012 實在太精彩，太感動了，一定要寫下來紀錄一下。</p>

<h3>前夜祭</h3>

<p>首先是經過 ihower 三年的邀請，今年終於邀請到 Ruby 之父 Matz 來到台灣。由於 Matz 提早到台灣，所以在 Ruby Conf 的前一天晚上也臨時加開了 Matz 見面會，能有這個近距離和大師接觸，聊天，提問的機會實在非常難得。不過也許是這時候大家把問題都問的差不多了，結果隔天 Matz 的 keynote 反而沒什麼人提問(笑)。</p>

<p><img src="http://blog.hsatac.net/images/rubyconftw2012/matz_and_i.jpg" alt="matz and I" /></p>

<!--more-->


<h3>Day 1</h3>

<p>這次場地不是在老地方中研院，而是在天母農訓中心國際會議廳，大家應該都是第一次來這個地方。場地設備算 OK ，不過沒有有線網路可用，然後剛好無線網路又悲劇了，後來大家好像都是靠自己的 3G 上網。午餐也是在這邊有 buffet 可以吃，非常好吃！一般訂便當完全無法相提並論。不過座位稍微矮小狹窄了一點，我這個身高的人坐一整天其實膝蓋很痛⋯⋯。</p>

<p>這個廳比中研院的大廳小，比中研院的小廳大。其實我覺得這樣的配置挺不錯的，不會離講者太遠，互動性比較高，也不會太擁擠。</p>

<p>一早就是 Matz 的 Keynote，同時講了三個主題，非常豐富；接下來是來自新加坡的 Wei Lu 分享 Pair Programming ，台風非常穩健。最令人驚喜的是 Jserv 的 mruby talk！從為什麼他們選擇 mruby 到 ARM 優化的細節，最後 live demo，連 Matz 在台下都聽得連連點頭。</p>

<blockquote class="twitter-tweet"><p>こういうmrubyの話が聞けるのは予想外だったなあ</p>&mdash; Yukihiro Matsumoto (@yukihiro_matz) <a href="https://twitter.com/yukihiro_matz/status/276903947690729472" data-datetime="2012-12-07T04:20:20+00:00">December 7, 2012</a></blockquote>


<script src="http://blog.hsatac.net//platform.twitter.com/widgets.js" charset="utf-8"></script>


<blockquote><p>「聽到這種 mruby 的資訊真是意料之外」</p></blockquote>

<p>下午 godfat 關於 concurrency application servers 的 talk 也很精彩，從實務出發，由淺入深。</p>

<p>這次與會的外國來賓和講者比例非常高，所以很多中文議程講者都臨時決定改用英文分享。其實我是覺得滿好的，身為一個國際性的研討會，盡可能照顧到所有人，讓外國來賓比較有參與感。</p>

<p>結果第一天的議程除了 godfat 以外全部都用英文演說了，恭喜 godfat 得到「Day 1 唯一中文講者」的成就 XD</p>

<h3>Party</h3>

<p>晚上參加了 official party，表定到晚上 12 點，因為我不太喝酒，本來想說去 social 一下就回家了。沒想到真的喝到 12 點才走(爆)</p>

<p>這個場合真的很好，可以很輕鬆的跟新朋友老朋友、各國來賓輕鬆的對談。跟好久不見的 dreamslab ben update 了一下近況；跟 jserv 聊了一下他的新公司；也跟慕凡交換了一下遊戲界甘苦談。</p>

<p>席間我問 Matz：「您去過許多 ruby conf, 這是第一次來 ruby conf taiwan ，您覺得怎麼樣？」</p>

<p>他回答，ruby conf taiwan 規模雖然小，但是質量水準很高，他相當驚訝。又問明年他是否願意再來，他說只要我們有邀請，他就會再來。</p>

<p>能讓 Matz 如此肯定，ihower 跟慕凡辦的真的是太優秀了。</p>

<h3>Day 2</h3>

<p>Day 2 是我原本就期待許久的議程，主要是 dlackty 的 devOps toolbox 會提到 chef，緊接著 thegiive 會介紹 puppet，這兩套工具我 survey 了一陣子，無法決定要用哪套，剛好來聽聽看心得。在兩位 Session 結束後也分別向兩位請教了一些 devOps 上的疑惑。</p>

<p>早上 Gosuke Miyashita 的 talk 也講了很多有趣的東西，例如他們的 <a href="https://github.com/paperboy-sqale/sqale-patches">anti fork bomb patch</a> 和 <a href="https://github.com/mizzy/openssh-script-auth">SSH router 實作</a>，讓我對 paperboy &amp; co. 這家陌生的日本公司有很深刻的印象。</p>

<p>下午 josephku 的 RubyMotion 也講的很精彩。 RubyMotion 也是我關注很久的技術，可以用 ruby 語法寫 iOS 對我這種被逼上梁山的 iOS 開發者來說有很大的吸引力。但是他的資料一直非常少，很訝異 josephku 能掌握並分享這樣一個新穎的技術，QA 時我也提問了兩個問題。會後本想找 josephku 認識一下，但緣鏗一面，希望日後有機會。</p>

<h3>End</h3>

<p>這次 Ruby Conf Taiwan 2012 的 Session 質量非常高，高到連外國來賓都很訝異。</p>

<blockquote class="twitter-tweet"><p>しかし，私が最適化の話とかをして，真面目に最適化の中身の質問を受けるカンファレンスは非常に久しぶりな気がする．台湾凄い．</p>&mdash; _ko1 (@_ko1) <a href="https://twitter.com/_ko1/status/277339165358714880" data-datetime="2012-12-08T09:09:44+00:00">December 8, 2012</a></blockquote>


<script src="http://blog.hsatac.net//platform.twitter.com/widgets.js" charset="utf-8"></script>


<blockquote><p>「不過, 讓我談到最佳化之類的議題、被認真地問最佳化核心部份的問題 conference 似乎非常久沒遇過了, 台灣真厲害。」</p></blockquote>

<p>我覺得這次議程篩選和安排的相當好，各領域的主題都有，展現了 Ruby 的多種可能性；深度也夠，不僅是聽眾收穫豐碩，講者們也能有互動。例如第一天 mruby 的幾位講者和來賓 jserv, matz, 高橋彼此會後也都能有交流。</p>

<p>聽 ihower 說這次篩選主題非常嚴格，有許多 sponser 的投稿都沒能入選，我覺得這樣非常好，贊助歸贊助，會給他們廣告的空間，不過維持大會的水準才是第一要務。</p>

<p>不誇張，這次 Ruby Conf Taiwan 2012 真的是我參加到目前為止台灣研討會裡最棒的一場，感謝 ihower 和慕凡以及所有工作人員的努力！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2010 MBP 升級 SSD 與 Fusion Drive]]></title>
    <link href="http://blog.hsatac.net/2012/11/macbook-pro-2010-mid-replace-optical-drive-with-ssd-and-fusion-drive/"/>
    <updated>2012-11-26T15:15:00+08:00</updated>
    <id>http://blog.hsatac.net/2012/11/macbook-pro-2010-mid-replace-optical-drive-with-ssd-and-fusion-drive</id>
    <content type="html"><![CDATA[<p>我現在用來開發 iOS 的電腦是公司提供的一台 Macbook Pro 13&#8221; 2010 mid 4G ram。使用上還算堪用，但時不時的 lag 以及 freeze 實在非常挑戰開發者的耐心。尤其當我 Xcode 開著，git 切換 branch 然後 Xcode 重新 index 的時候簡直慘不忍睹。</p>

<p>畢竟電腦還是自己在用，開心順手最重要，所以決定自己投資一點下去升級。因為光碟機很少在用，所以查了一下以前看過的硬碟轉接托架，意外發現非常便宜才 200 多元，還附拆機工具組。參考<a href="http://blog.lyhdev.com/2012/10/apple-macbook-pro-ssd.html">玩物喪誌</a>的心得一樣購買 Jeyi 的硬碟托架以及 Micron M4 7mm 超薄 SSD。別人踩過一次的雷就不用再踩了。</p>

<p>把光碟機拆下，原本的位置裝上 SSD。內裝的硬碟則不動。如果把內裝硬碟裝在硬碟托架的話硬碟的感震偵測會無法作用。拆機安裝部分參考 <a href="http://www.ifixit.com/Guide/MacBook+Pro+13-Inch+Unibody+Mid+2010+Optical+Drive+Replacement/4318/">ifixit</a> 的說明。最需要注意的是螺絲不要滑牙了。</p>

<p>在拆機的過程中也順便把家裡的 Mac mini server 8G 出包版的記憶體拆下與 MBP 的 4G 對調，兩組都是 DDR 3 1066 的規格，對換毫無困難。</p>

<p>裝上以後開機確認是否有抓到及辨識到 SSD 固態硬碟，link speed 也跑到 SATA II 全速。接著使用 Carbon Copy Cloner 先把原本的系統碟備份到外接 USB 硬碟。再改用 USB 硬碟開機，準備做 Fusion Drive。</p>

<p>會使用 Fusion Drive 的原因是 SSD 實在不夠大，原本要自己安排哪些目錄放 SSD，哪些少用放 HD ，但是使用 Fusion Drive 技術的話可以將 SSD 與 HD 變成一顆邏輯磁碟，而系統會自己幫你判斷哪些常用的檔案放在 SSD, 不常用的則移去 HD ，兼顧了速度與容量和便利性，似乎是個不錯的選擇，所以決定試試看。</p>

<p>參考 <a href="http://jollyjinx.tumblr.com/post/34638496292/fusion-drive-on-older-macs-yes-since-apple-has">Fusion drive on older Macs? YES!</a> 的說明做好 Fusion Drive，再用 Carbon Copy Cloner 把外接 USB 硬碟的資料複製回做好的 Fusion Drive。值得一提的是 Fusion Drive 似乎無法製作 Recovery Partition，這部份只好無視他的 warning 。</p>

<p>最後把 Fusion Drive 設為開機碟重開就完成了這次的升級。相關照片和紀錄都放在 <a href="http://www.facebook.com/media/set/?set=a.4857081506317.2196205.1275503618&amp;type=1&amp;l=bb8d23d675">Facebook 相簿</a> 中。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sentry 簡介投影片]]></title>
    <link href="http://blog.hsatac.net/2012/11/sentry-introduction-slides/"/>
    <updated>2012-11-13T11:53:00+08:00</updated>
    <id>http://blog.hsatac.net/2012/11/sentry-introduction-slides</id>
    <content type="html"><![CDATA[<script async class="speakerdeck-embed" data-id="509a1faa3a7976000202bd2c" data-ratio="1.2994923857868" src="http://blog.hsatac.net//speakerdeck.com/assets/embed.js"></script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP array 相加與 array_merge]]></title>
    <link href="http://blog.hsatac.net/2012/11/php-array-plus-array-versus-array-merge/"/>
    <updated>2012-11-06T13:17:00+08:00</updated>
    <id>http://blog.hsatac.net/2012/11/php-array-plus-array-versus-array-merge</id>
    <content type="html"><![CDATA[<p>今天聊到這個問題，喚起我沈睡的記憶…應該寫下來不然兩年後我大概又會忘了。</p>

<p>在 PHP 中 <code>array + array</code> 與 <code>array_merge</code> 的行為是不一樣的，陣列相加的效能會比 <code>array_merge</code> 來的好，但換來的代價是可能不是你預期的行為以及資料流失。</p>

<p>PHP 的陣列可以有 key 也可以沒有 key，也可以兩者混合。不過所謂的沒有 key ，其實他還是有 key ，只是是自動編上去的 int 流水號 key 例如 0,1,2,3&#8230;不管是哪一種，在陣列相加以及 <code>array_merge</code> 的行為都不一樣。</p>

<p>先講一下 <code>array_merge</code> 的行為，<code>array_merge($a, $b)</code> 的話，如果 <code>$a</code> 和 <code>$b</code> 裡面有 key 相同的元素，則會<strong>後蓋前</strong>也就是 <code>$b</code> 的值會蓋掉 <code>$a</code> 的值。那如果是沒有 key (流水號 key)的值，則會以附加在尾端 (append) 的方式合併上去，而所有流水號 key 的 index 則會重排。</p>

<!--more-->


<p>底下是一個簡單的例子：</p>

<figure class='code'><figcaption><span>array_merge</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="cp">&lt;?php</span>
</span><span class='line'><span class="nv">$arr_a</span> <span class="o">=</span> <span class="k">array</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="o">=&gt;</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="o">=&gt;</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">=&gt;</span><span class="mi">3</span><span class="p">);</span>
</span><span class='line'><span class="nv">$arr_b</span> <span class="o">=</span> <span class="k">array</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="o">=&gt;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
</span><span class='line'><span class="nb">var_dump</span><span class="p">(</span><span class="nb">array_merge</span><span class="p">(</span><span class="nv">$arr_a</span><span class="p">,</span> <span class="nv">$arr_b</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>結果為：</p>

<figure class='code'><figcaption><span>array_merge</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="x">array(5) {</span>
</span><span class='line'><span class="x">  [&quot;a&quot;]=&gt;</span>
</span><span class='line'><span class="x">  int(1)</span>
</span><span class='line'><span class="x">  [&quot;b&quot;]=&gt;</span>
</span><span class='line'><span class="x">  int(1)</span>
</span><span class='line'><span class="x">  [0]=&gt;</span>
</span><span class='line'><span class="x">  int(3)</span>
</span><span class='line'><span class="x">  [1]=&gt;</span>
</span><span class='line'><span class="x">  int(4)</span>
</span><span class='line'><span class="x">  [2]=&gt;</span>
</span><span class='line'><span class="x">  int(5)</span>
</span><span class='line'><span class="x">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>那如果是 <code>array + array</code> 的狀況，在有 key 的值的部分是相反的<strong>前蓋後</strong>，而沒有 key(流水號 key)的部分也會<strong>前蓋後</strong>，流水號 index 不會重排。我們用同樣的例子來觀察：</p>

<figure class='code'><figcaption><span>array + array</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="cp">&lt;?php</span>
</span><span class='line'><span class="nv">$arr_a</span> <span class="o">=</span> <span class="k">array</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="o">=&gt;</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="o">=&gt;</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">=&gt;</span><span class="mi">3</span><span class="p">);</span>
</span><span class='line'><span class="nv">$arr_b</span> <span class="o">=</span> <span class="k">array</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="o">=&gt;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
</span><span class='line'><span class="nb">var_dump</span><span class="p">(</span><span class="nv">$arr_a</span> <span class="o">+</span> <span class="nv">$arr_b</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>結果為：</p>

<figure class='code'><figcaption><span>array + array</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="x">array(4) {</span>
</span><span class='line'><span class="x">  [&quot;a&quot;]=&gt;</span>
</span><span class='line'><span class="x">  int(1)</span>
</span><span class='line'><span class="x">  [&quot;b&quot;]=&gt;</span>
</span><span class='line'><span class="x">  int(2)</span>
</span><span class='line'><span class="x">  [1]=&gt;</span>
</span><span class='line'><span class="x">  int(3)</span>
</span><span class='line'><span class="x">  [0]=&gt;</span>
</span><span class='line'><span class="x">  int(4)</span>
</span><span class='line'><span class="x">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>由此可知 <code>array + array</code> 和 <code>array_merge</code> 的行為是完全不一樣的，而大多數的情況陣列相加不會是我們想要的結果。請根據使用狀況謹慎選擇。</p>

<p>我只有在一個地方使用過陣列相加，在處理使用者設定的部分，系統有一個預設的設定陣列，使用者也會有使用者自訂的設定陣列，而使用者可能只設了其中幾項，這時把這兩個陣列相加，就可以組合出一個完整的使用者設定陣列，使用者沒設定的部分就由預設值陣列填補。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="cp">&lt;?php</span>
</span><span class='line'><span class="o">...</span>
</span><span class='line'><span class="k">static</span> <span class="k">protected</span> <span class="k">function</span> <span class="nf">_fillWithDefault</span><span class="p">(</span><span class="nv">$settings</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="nb">settype</span><span class="p">(</span><span class="nv">$settings</span><span class="p">,</span> <span class="s2">&quot;array&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="nv">$defaults</span> <span class="o">=</span> <span class="nx">self</span><span class="o">::</span><span class="na">getDefault</span><span class="p">();</span>
</span><span class='line'>  
</span><span class='line'>  <span class="k">foreach</span><span class="p">(</span><span class="nv">$settings</span> <span class="k">as</span> <span class="nv">$key</span><span class="o">=&gt;</span><span class="nv">$value</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nb">array_key_exists</span><span class="p">(</span><span class="nv">$key</span><span class="p">,</span> <span class="nv">$defaults</span><span class="p">))</span> <span class="nb">unset</span><span class="p">(</span><span class="nv">$settings</span><span class="p">[</span><span class="nv">$key</span><span class="p">]);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="k">return</span> <span class="nv">$settings</span> <span class="o">+</span> <span class="nv">$defaults</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>當然這個 case 寫成 <code>array_merge($defaults, $settings)</code> 也是可以達到一樣的效果，不過當時我覺得陣列相加效能較好，語意上也不會造成混淆，所以就採用這個寫法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Obj-C 單元測試非同步連線]]></title>
    <link href="http://blog.hsatac.net/2012/10/obj-c-unit-test-with-asynchronous-request/"/>
    <updated>2012-10-30T13:14:00+08:00</updated>
    <id>http://blog.hsatac.net/2012/10/obj-c-unit-test-with-asynchronous-request</id>
    <content type="html"><![CDATA[<p>使用 Xcode 的 OCUnit 來做單元測試網路連線時，由於 OCUnit 不會等 block 執行，所以會直接跳到 pass。一般正常作法應該是用 mock object 來測試，不過總有要實際測試真實連線的時候。這時可以使用以下的 snippet:</p>

<div><script src='https://gist.github.com/3978482.js?file='></script>
<noscript><pre><code>- (void)testLogin
{
    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
    [[miiiCasaServer getServer] login:@&quot;test@example.com&quot; andPassword:@&quot;password&quot; success:^(AFHTTPRequestOperation *operation, id responseObject) {
        assertThat(responseObject[@&quot;status&quot;], is(@&quot;ok&quot;));
        dispatch_semaphore_signal(semaphore);
    } failure:nil];
    while (dispatch_semaphore_wait(semaphore, DISPATCH_TIME_NOW))
        [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode
                                 beforeDate:[NSDate dateWithTimeIntervalSinceNow:10]];
    dispatch_release(semaphore);   // You don't need this if your deployment target &gt;= 6.0 and ARC enabled.
}
- (void)testLoginFail
{
    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
    [[miiiCasaServer getServer] login:@&quot;test@example.com&quot; andPassword:@&quot;wrongpassword&quot; success:nil failure:^(AFHTTPRequestOperation *operation, NSError *error) {
        assertThat([[error userInfo] objectForKey:@&quot;errmsg&quot;], containsString(@&quot;incorrect&quot;));
        assertThatInteger([error code], equalToInt(401));
        dispatch_semaphore_signal(semaphore);
    }];
    while (dispatch_semaphore_wait(semaphore, DISPATCH_TIME_NOW))
        [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode
                                 beforeDate:[NSDate dateWithTimeIntervalSinceNow:10]];
    dispatch_release(semaphore);   // You don't need this if your deployment target &gt;= 6.0 and ARC enabled.
}</code></pre></noscript></div>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[關於我的 Logo]]></title>
    <link href="http://blog.hsatac.net/2012/10/about-my-logo/"/>
    <updated>2012-10-21T11:07:00+08:00</updated>
    <id>http://blog.hsatac.net/2012/10/about-my-logo</id>
    <content type="html"><![CDATA[<p>在<a href="http://kvzhuang.blogspot.tw/2012/10/logo.html">莊神的部落格</a>被點名了，再加上我好像也沒講過我 Logo 的故事，只好發文解釋一下。</p>

<p><img src="http://www.loftwork.com/lw-content/users/8399/21a7cb1c760942198a0ace0efe362e78.gif" alt="Logo" /></p>

<!--more-->


<p>這個 Logo 是大學時代一個朋友傳給我的，一看就非常喜歡，比較熟的朋友大概都看得出來，完全能代表我這個人(笑)。所以馬上就拿來當 Logo 使用，一用就用到現在。</p>

<p>不過因為我朋友在網路掃圖掃太凶，他已經不記得這張圖是在哪裡取得，更不用說知道作者了，我一直很想知道這張圖的 license 獲得到原作者的授權，但始終無法找到，這件事就一直掛在我心上。</p>

<p>還好沒過多久，Google 推出了兇惡的「以圖找圖」功能，馬上就用這個功能下去找&#8230;&#8230;沒想到不知道是當初作者網站還沒建立起來、還是還沒索引到，又或者是那時以圖找圖搜尋技術還沒成熟，仍然是無功而返。</p>

<p>時光又過了一兩年，有一天我又突然想起這件事，再試著找看看，沒想到這時很精準的就找到了作者的網站。</p>

<p>作者是日本的 64CAT64 ，他的<a href="http://www.loftwork.com/portfolios/mushi/profile">網站</a>有許多他的作品。</p>

<p>找到作者後馬上寫 email 和他聯繫，解釋了一下我很喜歡這張圖，也用這張圖作為我的代表 Logo 許多年，想得知這張圖的 license ，看是否需要購買還是怎樣。</p>

<p>作者人非常好，只要我沒有拿來營利，他允許我免費使用他這張圖片，他也很高興我喜歡他的圖，只要我找個地方註記圖片作者的 URL 即可。所以後來我在 Blog footer 就加上了作者網站連結。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[同步 git 和 hg 的 repository]]></title>
    <link href="http://blog.hsatac.net/2012/10/sync-git-with-hg/"/>
    <updated>2012-10-17T10:20:00+08:00</updated>
    <id>http://blog.hsatac.net/2012/10/sync-git-with-hg</id>
    <content type="html"><![CDATA[<p>最近在玩 go，編輯器主要是使用 vim 搭配 <a href="https://github.com/nsf/gocode">gocode</a>。我習慣用 <a href="https://github.com/tpope/vim-pathogen">pathogen.vim</a> 來管理我的 vim 套件，不過 go 官方附的 vim syntax plugin 和 gocode 提供的 autocompletion plugin 目錄結構都無法直接當成 git submodule 引入我的 vim 設定中。</p>

<p>由於我個人潔癖作祟，不想再用 copy 的方式來管理我的 vim plugins，所以我決定自己把這兩份 plugin 抽出來獨立成各自的 git repositories，就可以當成 git submodule 引用了。</p>

<!--more-->


<p>gocode 的部分很容易，他原本就是 git，只要參考我之前的文章「<a href="http://blog.hsatac.net/2012/04/moving-files-from-one-git-repository-to-another-keeping-commit-history/">把 Git 中的目錄搬到另一個 Git 並保留 Commit</a>」就可以了。不過 go 的部分就沒這麼簡單了。go 的原始碼 host 在 google code 上，採用 hg，因此要想辦法先把他由 hg 轉換成 git 才行。</p>

<p>一開始使用的是 <a href="http://hg-git.github.com/">hg-git</a> 這套，不過在 gexport 這個過程非常緩慢，不知道是這個套件本身有問題還是 go 的 hg repository 太大了。試了兩天之後只好放棄，改用 <a href="http://offbytwo.com/git-hg/">git-hg</a> 這套。這套一樣也是使用 python 寫的，不過效率上就挺不錯的。使用上也很方便，直接 <code>git-hg clone https://code.google.com/p/go/</code> 出來就是 git 的目錄了。</p>

<p>值得一提的是，使用 homebrew 安裝 git-hg 時，由於 git-hg 有 require <a href="http://repo.or.cz/w/fast-export.git">fast-export</a> 這個 submodule，但 homebrew 安裝下來的 fast-export 居然不是最新的，導致無法使用。後來自己到 <code>/usr/local/Cellar/git-hg/HEAD</code> 把 fast-export 這個目錄移除，再 clone 一份新的 fast-export 就可以正常使用了。</p>

<p>我不想弄亂這個目錄，所以我是在 local 端再 clone 一次這個使用 git-hg clone 下來的 repository，再來作 <code>git filter-branch</code> 的動作。另外這個 repository 也順便丟到 github 上當作一個 go 的 git mirror 給有需要的人使用。</p>

<p>產出三個 repositories:</p>

<ul>
<li><p><a href="https://github.com/golangtw/go.vim">https://github.com/golangtw/go.vim</a> go 的 syntax plugin</p></li>
<li><p><a href="https://github.com/golangtw/gocode.vim">https://github.com/golangtw/gocode.vim</a> gocode 的 autocomplete plugin</p></li>
<li><p><a href="https://github.com/golangtw/go">https://github.com/golangtw/go</a> go 的 git mirror</p></li>
</ul>


<p>最後再寫一個 script 每天跑一次 cronjob 自動去 sync 就完成啦！</p>

<div><script src='https://gist.github.com/3903435.js?file='></script>
<noscript><pre><code>#!/bin/sh

# do gocode first
cd /Users/cat/golang.tw/gocode
git pull
git filter-branch -f --subdirectory-filter vim -- --all
git push pathogen master
git fetch
git reset --hard origin/master

# do git-hg sync go
cd /Users/cat/golang.tw/go.git
git-hg pull
git push origin master

# do go.vim

cd /Users/cat/golang.tw/go.vim
git pull
git filter-branch -f --subdirectory-filter misc/vim -- --all
git push github master
git fetch
git reset --hard origin/master
</code></pre></noscript></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[8 款我最近常用的 command line 工具]]></title>
    <link href="http://blog.hsatac.net/2012/09/8-command-line-tools-i-have-been-using-lately/"/>
    <updated>2012-09-28T13:45:00+08:00</updated>
    <id>http://blog.hsatac.net/2012/09/8-command-line-tools-i-have-been-using-lately</id>
    <content type="html"><![CDATA[<p>介紹八款我最近常用的 command line 工具，對開發很有幫助。</p>

<!--more-->


<h2>1. Mosh</h2>

<h3>說明</h3>

<p>不會斷線的 ssh
<a href="http://mosh.mit.edu/">http://mosh.mit.edu/</a></p>

<h3>安裝</h3>

<p>client 和 server 都需要安裝</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>packer mosh (Archlinux)
</span><span class='line'>yum install mosh (Centos)
</span><span class='line'>brew install mobile-shell (MacOS)</span></code></pre></td></tr></table></div></figure>


<h3>使用</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>mosh ash_wu@myserver.com
</span><span class='line'>mosh myserver.com -- screen -rx</span></code></pre></td></tr></table></div></figure>


<h2>2. Mitmproxy</h2>

<h3>說明</h3>

<p>middleman proxy 可用來 debug , fiddler 的 *nix 版</p>

<p><a href="http://mitmproxy.org">http://mitmproxy.org</a></p>

<h3>安裝</h3>

<p>使用 python 套件管理 pip 安裝</p>

<p>有 https 需求的話則需要安裝他的憑證</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pip install mitmproxy</span></code></pre></td></tr></table></div></figure>


<h3>使用</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>mitmproxy
</span><span class='line'>mitmdump</span></code></pre></td></tr></table></div></figure>


<h3>擴充</h3>

<p>mitmproxy 提供許多 hook 可以自訂擴充，以 python 編寫即可。可參考我的文章</p>

<p><a href="http://blog.hsatac.net/2012/08/mitmproxy-modify-request-host-and-port-howto/">http://blog.hsatac.net/2012/08/mitmproxy-modify-request-host-and-port-howto/</a></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>mitmproxy -s test.py</span></code></pre></td></tr></table></div></figure>


<h2>3. pdsh/pdcp/rpdcp</h2>

<h3>說明</h3>

<p>一次大量對許多機器下指令/複製檔案</p>

<h3>安裝</h3>

<p>要使用 pdcp 的話 client 和 server 都要裝</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>packer pdsh (Archlinux)
</span><span class='line'>yum install pdsh (Centos)
</span><span class='line'>brew install pdsh (MacOS)</span></code></pre></td></tr></table></div></figure>


<h3>使用</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pdsh -w web[01-10],static[7,9-10] ls
</span><span class='line'>pdcp -w ash_wu@dmyserver[1-2].com test.py /home/ash_wu/</span></code></pre></td></tr></table></div></figure>


<h2>4. htop</h2>

<h3>說明</h3>

<p>better top. 可以直接看 process tree, 直接砍掉</p>

<p><a href="http://htop.sourceforge.net/">http://htop.sourceforge.net/</a></p>

<h2>5. goaccess</h2>

<p>看 apache/nginx log</p>

<p><a href="http://goaccess.prosoftcorp.com/">http://goaccess.prosoftcorp.com/</a></p>

<h3>使用</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>goaccess &lt;apache_access_log or nginx_access_log></span></code></pre></td></tr></table></div></figure>


<h2>6. ack, ag</h2>

<h3>說明</h3>

<p>Ack - Better than grep</p>

<p>Ag - Better than Ack</p>

<p>比 grep 更方便好用</p>

<p><a href="http://betterthangrep.com/">http://betterthangrep.com/</a></p>

<p><a href="https://github.com/ggreer/the_silver_searcher">https://github.com/ggreer/the_silver_searcher</a></p>

<h3>安裝</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>packer the_silver_searcher
</span><span class='line'>brew install the_silver_searcher</span></code></pre></td></tr></table></div></figure>


<h3>同場加映</h3>

<p>ack.vim</p>

<p><a href="https://github.com/mileszs/ack.vim">https://github.com/mileszs/ack.vim</a></p>

<p>ag.vim</p>

<p><a href="https://github.com/epmatsw/ag.vim">https://github.com/epmatsw/ag.vim</a></p>

<h2>7. tig</h2>

<p>git CUI client</p>

<p><a href="https://github.com/jonas/tig">https://github.com/jonas/tig</a></p>

<h2>8. bashmarks</h2>

<h3>說明</h3>

<p>快速在目錄間切換</p>

<p><a href="https://github.com/huyng/bashmarks">https://github.com/huyng/bashmarks</a></p>

<h3>安裝</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git clone git://github.com/huyng/bashmarks.git
</span><span class='line'>make install
</span><span class='line'>source ~/.local/bin/bashmarks.sh from within your ~.bash_profile or ~/.bashrc file</span></code></pre></td></tr></table></div></figure>


<h3>使用</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>s &lt;bookmark_name> - Saves the current directory as "bookmark_name"
</span><span class='line'>g &lt;bookmark_name> - Goes (cd) to the directory associated with "bookmark_name"
</span><span class='line'>p &lt;bookmark_name> - Prints the directory associated with "bookmark_name"
</span><span class='line'>d &lt;bookmark_name> - Deletes the bookmark
</span><span class='line'>l                 - Lists all available bookmarks</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[身體調校聖經]]></title>
    <link href="http://blog.hsatac.net/2012/09/the-4-hours-body/"/>
    <updated>2012-09-20T23:23:00+08:00</updated>
    <id>http://blog.hsatac.net/2012/09/the-4-hours-body</id>
    <content type="html"><![CDATA[<p><img src="http://blog.hsatac.net/images/the_4_hours_body/cover.jpg" alt="cover" /></p>

<blockquote><p>⋯⋯《身體調校聖經》所提供的，是對人類重建身體的全新探索，全盤收錄幾百位優異運動員、幾十位醫師，以及幾千小時讓人目瞪口呆的個人實驗智慧；從奧林匹克訓練中心到地下實驗室，從矽谷到南非，作者提摩西．費里斯念茲在茲的改變人生問題是：</p><p>　　對所有關於身體的事情，如何以最小的改變來創造最大的成果？⋯⋯</p></blockquote>


<p>前陣子很紅的《<a href="http://www.books.com.tw/exep/prod/booksfile.php?item=0010541859">身體調校聖經</a>》，看了許多人的心得和推薦以後覺得很有意思，也買了一本。</p>

<p>我的故事很平常，跟大多數人一樣，入伍時有著健康的好身材，退伍就業沒多久就因為天天坐在電腦前缺乏運動而發胖。從 70 kg 暴增到 90 kg。一直都有要減重的念頭，卻遲遲沒有實行。直到看了這本書。</p>

<!--more-->


<p>我覺得這本書給了我兩個很重要的觀念：一個是書中所提的「原宿時刻」。故事不在這邊細說，留給各位買書後自行閱讀。我就和故事的主角一樣，突然領悟到，在生命中我一直對最重要的資產——身體視而不見。下意識去忽略他。我知道我需要減重，我知道我要吃得健康，我知道我要維持運動。可是我總是什麼都不去做，就這樣等著看會不會有什麼神奇的事情發生。我每天在寫程式，學習新技術。不斷磨練自己，不斷改進自己的產品、開發流程。因為我知道每天都進步一點，持久下來就會很可觀。可是對自己身體的態度，我卻偏偏是我最瞧不起的那種人。意識到這點以後，要做改變一點都不困難了。</p>

<p>第二個我覺得很棒的觀點是：「測量」。</p>

<p>我從沒想過自己的身體也可以當玩具。我每個月都在買新玩具，沉迷於新玩具帶給我的刺激。但是陪伴我最久，離我最近的身體我居然沒想過要好好去研究他。書中提供了許多測量的方式和策略，只要有了測量和資料，我就可以分析方法是否有效，要如何改變或是繼續加強。就跟我們平時在優化程式、調校伺服器一樣。這不正是我們最擅長的嗎？</p>

<p>除了帶給我這兩點觀念外，書裡也充滿了許多有用的知識和各種你沒想過/沒聽過的調校方法。真的很值得買一本，偶爾隨手翻翻都好，會有意想不到的收穫。</p>

<p>最後附上我按書中提供的方法，選擇比較適合我生活型態的減重方式，運行一個月以來的成果。</p>

<p>我使用的是「低醣減脂法」。不吃米麥糖奶和水果，只吃菜肉蛋豆；不喝飲料，只喝開水或黑咖啡/無糖茶。每天早上起床一小時內一定吃早餐並且補充蛋白質。每週六是作弊日，可以盡情吃任何想吃的東西。</p>

<p>洗澡時洗冷水澡，並且固定時間測量自己的體重/體脂肪/腰圍等等。</p>

<p>從 8/21 實行到今天結束剛好 30 天整。我的成果：腰圍由 101 cm 縮減到 93 cm；體重從 92.3 kg 減輕到 86 kg。後面附的是我體重曲線圖。</p>

<p><img src="http://blog.hsatac.net/images/the_4_hours_body/weight.png" alt="weight" /></p>

<p>還沒達到我的理想體重，因此我還會再持續好一陣子。以前減重帶給我的只有節制和痛苦。但現在我和我自己的身體玩的不亦樂乎，再也不是一件令人難以忍受的事了。我對自己身體的探索，還會再繼續下去。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[開發 Golang 的 IDEs]]></title>
    <link href="http://blog.hsatac.net/2012/09/golang-ides/"/>
    <updated>2012-09-19T00:34:00+08:00</updated>
    <id>http://blog.hsatac.net/2012/09/golang-ides</id>
    <content type="html"><![CDATA[<p>介紹一些開發 Golang 的 IDEs</p>

<p>首先是我慣常使用的 <a href="http://www.sublimetext.com/2">Sublime Text 2</a> 搭配  <a href="https://github.com/disposaboy/gosublime">gosublime</a> 外掛。</p>

<p><img src="http://blog.hsatac.net/images/golang_ides/subl.png" alt="gosublime" /></p>

<!--more-->


<p>以及也是我慣用的 vim + <a href="https://github.com/nsf/gocode/">gocode</a></p>

<p>在 <code>$GOROOT/misc/vim</code> 下已經有提供給 vim 使用的 syntax, indent, plugin 等，全部複製到 <code>~/.vim</code> 下面即可。如果不知道 go 安裝的位置可以使用 <code>go env</code> 來查詢。</p>

<p>按 gocode 的說明安裝完成後就可以在 vim 裡面使用 golang 的 autocompletion 了。</p>

<p><img src="http://blog.hsatac.net/images/golang_ides/vim.png" alt="vim + gocode" /></p>

<p>提了 vim 也不得不提 emacs. Emacs 一樣使用 <code>$GOROOT/misc/emacs</code> 下提供的檔案以及搭配 gocode 做自動完成。</p>

<p><img src="http://blog.hsatac.net/images/golang_ides/emacs.png" alt="emacs + gocode" /></p>

<p>再來介紹一個大陸開發的 <a href="http://code.google.com/p/golangide/">golangide</a> 相當優秀，也是跨三平台版本。安裝就可以使用了，不需要多餘的設定。</p>

<p><img src="http://blog.hsatac.net/images/golang_ides/golangide.png" alt="golangide" /></p>

<p><a href="http://code.google.com/p/goclipse/">goeclipse</a>
Golang 的 Eclipse plugin…Eclipse 現在完全是個萬能 editor.</p>

<p><img src="http://blog.hsatac.net/images/golang_ides/goeclipse.png" alt="goeclipse" /></p>

<p><a href="http://www.zeusedit.com/go.html">zeus</a> 是一個 windows 的 programming editor，也提供了深度支援開發 golang。</p>

<iframe width="560" height="315" src="http://www.youtube.com/embed/CZ5Yl0KnbKs" frameborder="0" allowfullscreen></iframe>




<iframe width="560" height="315" src="http://www.youtube.com/embed/84i7H-E0YUM" frameborder="0" allowfullscreen></iframe>


<p>Zeus 整合的相當好，包括 debugger, build manager, package manager 都有提供，比較有完整 IDE 的感覺。但完整版是要付費購買的。不管如何，選擇一個喜歡，順手合自己意的才是最重要的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自動檢查 git branch 是否 merge 過]]></title>
    <link href="http://blog.hsatac.net/2012/08/git-branching-model-regular-check/"/>
    <updated>2012-08-12T12:28:00+08:00</updated>
    <id>http://blog.hsatac.net/2012/08/git-branching-model-regular-check</id>
    <content type="html"><![CDATA[<p>按照一般 <a href="http://nvie.com/posts/a-successful-git-branching-model/">Git branching model</a> 來開發，當團隊人數稍多時，管理 Git branch 會變得有些麻煩。Branch 數量多之外，也很難記得哪些 branches 是已經 merge 進主幹、不再需要可以刪除；或者哪些 branches 沒有 merge 進主幹但已經放棄不用。這時就需要一些自動化的 script 幫助管理。</p>

<!--more-->


<p>本來是想全部用 bash 寫，不過功力不夠，最後還是偷懶用 ruby 了。</p>

<p>這個 script 會先檢查哪些 branches 已經 merge 過，如果沒有特殊理由就可以刪除了。也可以把刪除的動作寫在 script 讓他自動化，不過我這邊選擇保留一些手動的彈性。</p>

<p>再來是檢查哪些 branches 已經開很久了(開超過一個月)，卻又沒有 merge 進主幹，這時管理者可以看一下這些 branches 是否已經不再使用，可以刪除。</p>

<div><script src='https://gist.github.com/3246217.js?file='></script>
<noscript><pre><code>#!/usr/bin/env ruby
require 'rubygems'
require 'active_support'

merged = `cd /home/m/git/repositories/miiicasa.git &amp;&amp; git branch --merged master | grep -v master`
not_merged_cmd = 'cd /home/m/git/repositories/miiicasa.git &amp;&amp; git branch | grep -v master | grep -v support | grep -v qa'
for line in merged.split(&quot;\n&quot;)
  not_merged_cmd += '| grep -v ' + line
end
puts &quot;This is a regular check of miiiCasa.git branches\n&quot;
puts &quot;List below are branches already been merged into [master]:&quot;
puts &quot;Please check if they are still needed, grb delete them otherwise.\n&quot;
puts merged

puts &quot;\n--------------------\n\n&quot;

puts 'List below are branches order than 1 month and have NOT been merged into [master]:'
puts &quot;Please check if they are abandoned or forgotten.&quot;
not_merged = `#{not_merged_cmd}`
for line in not_merged
  date =  /\S+_([0-9]+)_/.match(line)[1]
  puts line if 1.month.ago &gt; Date.parse(date)
end</code></pre></noscript></div>


<p>我們團隊對於 branch 命名有規定，中間一定是八位數字的日期，例如 feature_20120812_sthcool 以便分辨這個 branch 的開創時間。如果沒有這樣的命名規定的話，也可以透過下面這樣的 script 來找出最後 active 的時間。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for k in `git branch|perl -pe s/^..//`;do echo -e `git show --pretty=format:"%Cgreen%ci %Cblue%cr%Creset" $k|head -n 1`\\t$k;done|sort -r</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用 mitmproxy 替換 request host 和 port]]></title>
    <link href="http://blog.hsatac.net/2012/08/mitmproxy-modify-request-host-and-port-howto/"/>
    <updated>2012-08-09T11:25:00+08:00</updated>
    <id>http://blog.hsatac.net/2012/08/mitmproxy-modify-request-host-and-port-howto</id>
    <content type="html"><![CDATA[<p>常在開發或測試階段會有更換 http request host 的需求。
簡單一點的方法就是直接更改 /etc/hosts 檔案。但如果連 port 都需要轉，那就需要其他方式了。</p>

<p>一般在 windows 上是推薦 <a href="http://www.fiddler2.com">fiddler 2</a> 這套軟體，非常好用。可以參考 <a href="http://blog.xuite.net/vexed/tech/62341108">vexed 的文章</a>。</p>

<p>不過在其他平台，可以使用 <a href="http://mitmproxy.org">mitmproxy</a> 這套軟體，他是 CUI 介面，操作上沒有 fiddler 那樣直覺，但稍微看一下說明即可上手。</p>

<p>mitmproxy 提供許多 API 讓使用者自訂需求，都使用 Python 來編寫。不過關於 script 的 document 較少，可以參考<a href="http://mitmproxy.org//doc/scripts.html">官方說明</a>有簡單的範例，或者使用 <code>pydoc libmproxy.flow.Request</code> 這樣的指令來查閱，再不然就只能直接看<a href="https://github.com/cortesi/mitmproxy/">原始碼</a>了。</p>

<!--more-->


<p>使用方法很簡單，首先開一個檔案例如 mitmproxy.py</p>

<div><script src='https://gist.github.com/3300699.js?file='></script>
<noscript><pre><code>def request(context, flow):
    if &quot;miiicasa.com&quot; in flow.request.host:
        flow.request.host = &quot;192.168.254.9&quot;
        flow.request.port = &quot;50113&quot;</code></pre></noscript></div>


<p>開啟 mitmproxy 的時候帶參數 -s <code>mitmproxy -s mitmproxy.py</code> 或者進入 mitmproxy 後按快速鍵 s 輸入 mitmproxy.py 載入即可。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git 救回已刪除的檔案]]></title>
    <link href="http://blog.hsatac.net/2012/07/git-restore-removed-files/"/>
    <updated>2012-07-28T20:30:00+08:00</updated>
    <id>http://blog.hsatac.net/2012/07/git-restore-removed-files</id>
    <content type="html"><![CDATA[<p>在 Git 操作的過程中，有些檔案是無法用 git checkout 救回來的。這些稱之為 unreachable files 。例如你 git add 了，但還沒 commit 就 pull ，這時這些檔案會被刪除，但因為沒有 commit 所以無法用 reset 救回。並且在 git reflog 裡面也不會有紀錄。</p>

<p>還好 Git 非常萬能，可以使用 <code>git fsck --cache --unreachable</code> 會列出一堆檔案的 bash ，再使用 <code>git show &lt;hash&gt;</code> 逐一檢視檔案內容即可救回失去的檔案。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP openssl_pkey_get_details implement in c]]></title>
    <link href="http://blog.hsatac.net/2012/06/php-openssl-pkey-get-details-implement-in-c/"/>
    <updated>2012-06-14T10:49:00+08:00</updated>
    <id>http://blog.hsatac.net/2012/06/php-openssl-pkey-get-details-implement-in-c</id>
    <content type="html"><![CDATA[<p>It&#8217;s easy to generate a RSA keypair in PHP, just like this:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;?php
</span><span class='line'>// Create the keypair
</span><span class='line'>$res=openssl_pkey_new();
</span><span class='line'>
</span><span class='line'>// Get private key
</span><span class='line'>openssl_pkey_export($res, $privkey);
</span><span class='line'>
</span><span class='line'>// Get public key
</span><span class='line'>$pubkey=openssl_pkey_get_details($res);
</span><span class='line'>$pubkey=$pubkey["key"];
</span><span class='line'>?&gt;</span></code></pre></td></tr></table></div></figure>


<p>But when it comes to C, it&#8217;s not that simple.</p>

<p>You might want to use <code>RSA_generate_key</code> and then <code>PEM_write_RSAPublicKey</code>, but in fact, the output format of PHP&#8217;s <code>openssl_pkey_get_details</code> is not a RSA public key.</p>

<p>If you want to get the same result in C, you have to convert your RSA keypair into EVP keypair.</p>

<!--more-->


<p>Here&#8217;s my sample script:</p>

<div><script src='https://gist.github.com/2909583.js?file='></script>
<noscript><pre><code>/*
example of c equivalent to php
&lt;?php
// Create the keypair
$res=openssl_pkey_new();

// Get private key
openssl_pkey_export($res, $privkey);

// Get public key
$pubkey=openssl_pkey_get_details($res);
$pubkey=$pubkey[&quot;key&quot;];
?&gt;
*/
#include&lt;stdio.h&gt;
#include&lt;openssl/rsa.h&gt;
#include&lt;openssl/evp.h&gt;

EVP_PKEY *pubkey_a,*privkey_a;

generate_keys ()
{
  RSA *rsa, *pub_rsa, *priv_rsa;
  int len;
  unsigned char *buf, *p;

  rsa = RSA_generate_key (1024, RSA_F4, NULL, (char *) stdout);

  buf = (char *) malloc (2048);

  p = buf;

  len = i2d_RSAPublicKey (rsa, &amp;p);
  len += i2d_RSAPrivateKey (rsa, &amp;p);

  RSA_free (rsa);

  p = buf;
  pub_rsa = d2i_RSAPublicKey (NULL, &amp;p, (long) len);
  len -= (p - buf);
  priv_rsa = d2i_RSAPrivateKey (NULL, &amp;p, (long) len);

  if ((pub_rsa == NULL) || (priv_rsa == NULL))
    ERR_print_errors_fp (stderr);


  pubkey_a = EVP_PKEY_new ();
  privkey_a = EVP_PKEY_new ();

  EVP_PKEY_set1_RSA (pubkey_a, pub_rsa);
  EVP_PKEY_set1_RSA (privkey_a, priv_rsa);

  RSA_free (pub_rsa);
  RSA_free (priv_rsa);

}

main()
{   

  EVP_PKEY *pubkey,*privkey;

  generate_keys ();

  pubkey=pubkey_a;
  privkey=privkey_a;

  PEM_write_PUBKEY(stdout, pubkey);
  return 0;
 
}</code></pre></noscript></div>


<p>You can test it by folloing commands:
<code>gcc -o key key.c -lssl &amp;&amp; ./key</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用 ec2 的 Name tag 設定 hostname]]></title>
    <link href="http://blog.hsatac.net/2012/06/set-ec2-hostname-from-name-tag/"/>
    <updated>2012-06-07T15:50:00+08:00</updated>
    <id>http://blog.hsatac.net/2012/06/set-ec2-hostname-from-name-tag</id>
    <content type="html"><![CDATA[<p>如果 hostname 每一台都要自己一一指定相當麻煩，寫了一個小 script 放在開機時執行，抓取 instance-id 後取得 Name tag 再設定成 hostname。</p>

<div><script src='https://gist.github.com/2887240.js?file='></script>
<noscript><pre><code>#!/usr/bin/env ruby
require 'rubygems'
require 'aws-sdk'

instance_id = `wget &quot;http://169.254.169.254/latest/meta-data/instance-id&quot; -o /dev/null -O /dev/stdout`
config = {:access_key_id =&gt; '',
          :secret_access_key =&gt; ''}
AWS.config(config)
ec2 = AWS::EC2.new
ec2 = ec2.regions['ap-northeast-1']
hostname = ec2.instances[instance_id].tags.to_h[&quot;Name&quot;]
`hostname #{hostname}`</code></pre></noscript></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[動態產生 ec2 的 hosts 檔案]]></title>
    <link href="http://blog.hsatac.net/2012/06/generate-aws-ec2-hosts-file/"/>
    <updated>2012-06-07T11:43:00+08:00</updated>
    <id>http://blog.hsatac.net/2012/06/generate-aws-ec2-hosts-file</id>
    <content type="html"><![CDATA[<p>這個議題類似上一篇 <a href="http://blog.hsatac.net/2012/06/aws-ec2-setup-dynamic-dns-using-route-53/">利用 Route 53 設定 Ec2 動態 DNS</a> ，同樣也是要解決主機名稱對應浮動 ip 的問題。</p>

<p>雖然現在用完整域名已經可以對應到 ip ，但是還是有很多時候我們的主機需要知道主機名稱和 ip 的對應。</p>

<p>這個問題大概也是可以用 hosts 或 dns 來解決，不過由於我已經把 yp nis 架設起來，其他機器可以直接吃 nis 伺服器的 hosts 檔案，所以決定用 hosts 這個方式來處理。</p>

<p>概念很簡單，利用 ec2 api sdk 抓取正在運行的主機列表，一一寫入 /etc/hosts 後再重新 make yp 的資料庫。</p>

<p>設個排程每個小時跑一下或開新機器時手動執行一下即可。</p>

<p>script 如下：</p>

<div><script src='https://gist.github.com/2881131.js?file='></script>
<noscript><pre><code>#!/usr/bin/env ruby
# coding: utf-8
require 'rubygems'
require 'aws-sdk'

config = {:access_key_id =&gt; '',
          :secret_access_key =&gt; ''}
AWS.config(config)
ec2 = AWS::EC2.new
ec2 = ec2.regions['ap-northeast-1']

hosts = []
hosts &lt;&lt; &quot;127.0.0.1\tlocalhost localhost.localdomain&quot;
ec2.instances.each do |instance|
  next unless instance.status == :running
  tags = instance.tags.to_h
  hosts &lt;&lt; &quot;#{instance.private_ip_address}\t#{tags[&quot;Name&quot;]}&quot;
end

`cp -p /etc/hosts /etc/hosts.bak`
open(&quot;/etc/hosts.new&quot;, &quot;w&quot;) {|f| f.write hosts.join(&quot;\n&quot;)+&quot;\n&quot;}
is_same = system(&quot;diff -q /etc/hosts.new /etc/hosts &gt; /dev/null 2&gt;/dev/null&quot;)
unless is_same
  `cp -p /etc/hosts.new /etc/hosts`
end</code></pre></noscript></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[利用 route 53 設定 ec2 動態 DNS]]></title>
    <link href="http://blog.hsatac.net/2012/06/aws-ec2-setup-dynamic-dns-using-route-53/"/>
    <updated>2012-06-06T14:44:00+08:00</updated>
    <id>http://blog.hsatac.net/2012/06/aws-ec2-setup-dynamic-dns-using-route-53</id>
    <content type="html"><![CDATA[<p>最近在玩 aws ec2 第一個一定會碰到的問題就是 ip 都是動態的，每次開機都不一樣。造成大部分的佈署方式會有問題，一般都是用動態 dns 來解決，原本想自己架 bind 或 djbdns ，但是架好以後還要處理動態 dns 更新的機制，於是把想法動到價格低廉的 route 53 身上，他有完整的 restful api 應該很符合我的需求。</p>

<p>找到這個 <a href="http://www.linkdata.se/downloads/sourcecode/other/route53-dyndns.sh">script</a> 是利用 http://checkip.dyndns.com 來抓取自己 ip 再更新 route 53 的 A record 。</p>

<p>不過 ec2 的 public dns 有一個特性，從外面解會解到 public ip ，但是從裡面解會解到 private ip ，同一個 availability zone 用 private ip 互連是不多收費的。</p>

<p>如果設 A record 使用 public 連線，就沒有這個優勢了，所以我改用 CNAME 指到 ec2 的 public dns。然後原本取得 ip 的部分也改用 aws 取 meta-data 就可以了。</p>

<p>具體作法，可以開一個 subdomain 例如 ec2.hsatac.net ，然後把這個 subdomain delegate 給我們的 route 53 來解析。在 DNS 的部分新增一筆 NS  <code>ec2.hsatac.net</code> 然後 server 設定為 route 53 給的那幾組即可。</p>

<!-- more -->


<p>修改過後的 script 如下：</p>

<div><script src='https://gist.github.com/2880516.js?file='></script>
<noscript><pre><code>#!/bin/sh

# Setup dynamic dns on Route 53 for aws ec2 (CNAME)
#
# Modified from Johan Lindh's script
#
# Script requirements:
#
#  wget
#  grep
#  sed
#  dig
#  cut
#  openssl
#  base64
#
# Most if not all of these come standard on *nix distros.
#

# The domain and host name to update
# and the desired TTL of the record
Domain=your.domain.net
Hostname=`hostname`
NewTTL=600

# The Amazon Route 53 zone ID for the domain
# and the Amazon ID and SecretKey. Remember to
# ensure that this file can't be read by
# unauthorized people!
ZoneID=Z1234567890
AmazonID=A1234567890
SecretKey=GR$WYTJ%Y$@GY%J$%GY@H

# Enter the URL used to check extern IP
CheckIPURL='http://169.254.169.254/latest/meta-data/public-hostname'

# Enter some static text that immediately preceeds the current IP in the HTML output
# Note that you'll probably need to look at the actual HTML code to find this
CheckIPText='Current IP Address:'

###############################################################
# You should not need to change anything beyond this point
###############################################################

# Find an authoritative AWS R53 nameserver so we get a clean TTL
AuthServer=$(dig NS $Domain | grep -v ';' | grep -m 1 awsdns | grep $Domain | cut -f 6)
if [ &quot;$AuthServer&quot; = &quot;&quot; ]; then
  echo The domain $Domain has no authoritative Amazon Route 53 name servers
  exit 1
fi

# Get the record and extract its parts
Record=$(dig @$AuthServer A $Hostname.$Domain | grep -v &quot;;&quot; | grep &quot;$Hostname\.$Domain&quot;)
OldType=$( echo $Record | cut -d ' ' -f 4 )
OldTTL=$( echo $Record | cut -d ' ' -f 2 )
OldIP=$( echo $Record | cut -d ' ' -f 5 | sed s/.$//)

# Make sure it is an A record (could be CNAME)
if [ &quot;$Record&quot; != &quot;&quot; -a &quot;$OldType&quot; != &quot;CNAME&quot; ]; then
  echo $Hostname.$Domain has a $OldType record, expected 'CNAME'
  exit 1
fi

# Retrieve the current IP
CurrentIP=$(wget &quot;$CheckIPURL&quot; -o /dev/null -O /dev/stdout)

# Changeset preamble
Changeset=&quot;&quot;
Changeset=$Changeset&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;&quot;
Changeset=$Changeset&quot;&lt;ChangeResourceRecordSetsRequest xmlns=\&quot;https://route53.amazonaws.com/doc/2010-10-01/\&quot;&gt;&quot;
Changeset=$Changeset&quot;&lt;ChangeBatch&gt;&lt;Comment&gt;Update $Hostname.$Domain&lt;/Comment&gt;&lt;Changes&gt;&quot;

if [ &quot;$OldIP&quot; != &quot;&quot; ]; then
  # Add a DELETE request to the changeset
  Changeset=$Changeset&quot;&lt;Change&gt;&quot;
  Changeset=$Changeset&quot;&lt;Action&gt;DELETE&lt;/Action&gt;&quot;
  Changeset=$Changeset&quot;&lt;ResourceRecordSet&gt;&quot;
  Changeset=$Changeset&quot;&lt;Name&gt;$Hostname.$Domain.&lt;/Name&gt;&quot;
  Changeset=$Changeset&quot;&lt;Type&gt;CNAME&lt;/Type&gt;&quot;
  Changeset=$Changeset&quot;&lt;TTL&gt;$OldTTL&lt;/TTL&gt;&quot;
  Changeset=$Changeset&quot;&lt;ResourceRecords&gt;&quot;
  Changeset=$Changeset&quot;&lt;ResourceRecord&gt;&quot;
  Changeset=$Changeset&quot;&lt;Value&gt;$OldIP&lt;/Value&gt;&quot;
  Changeset=$Changeset&quot;&lt;/ResourceRecord&gt;&quot;
  Changeset=$Changeset&quot;&lt;/ResourceRecords&gt;&quot;
  Changeset=$Changeset&quot;&lt;/ResourceRecordSet&gt;&quot;
  Changeset=$Changeset&quot;&lt;/Change&gt;&quot;
fi

# Add CREATE request to the changeset
Changeset=$Changeset&quot;&lt;Change&gt;&quot;
Changeset=$Changeset&quot;&lt;Action&gt;CREATE&lt;/Action&gt;&quot;
Changeset=$Changeset&quot;&lt;ResourceRecordSet&gt;&quot;
Changeset=$Changeset&quot;&lt;Name&gt;$Hostname.$Domain.&lt;/Name&gt;&quot;
Changeset=$Changeset&quot;&lt;Type&gt;CNAME&lt;/Type&gt;&quot;
Changeset=$Changeset&quot;&lt;TTL&gt;$NewTTL&lt;/TTL&gt;&quot;
Changeset=$Changeset&quot;&lt;ResourceRecords&gt;&quot;
Changeset=$Changeset&quot;&lt;ResourceRecord&gt;&quot;
Changeset=$Changeset&quot;&lt;Value&gt;$CurrentIP&lt;/Value&gt;&quot;
Changeset=$Changeset&quot;&lt;/ResourceRecord&gt;&quot;
Changeset=$Changeset&quot;&lt;/ResourceRecords&gt;&quot;
Changeset=$Changeset&quot;&lt;/ResourceRecordSet&gt;&quot;
Changeset=$Changeset&quot;&lt;/Change&gt;&quot;

# Close the changeset
Changeset=$Changeset&quot;&lt;/Changes&gt;&quot;
Changeset=$Changeset&quot;&lt;/ChangeBatch&gt;&quot;
Changeset=$Changeset&quot;&lt;/ChangeResourceRecordSetsRequest&gt;&quot;

if [ &quot;$OldIP&quot; != &quot;$CurrentIP&quot; ]; then
  # Get the date at the Amazon servers
  CurrentDate=$(wget -q -S https://route53.amazonaws.com/date -O /dev/null 2&gt;&amp;1 | grep Date | sed 's/.*Date: //')

  # Calculate the SHA1 hash and required headers
  Signature=$(echo -n $CurrentDate | openssl dgst -binary -sha1 -hmac $SecretKey | base64)
  DateHeader=&quot;Date: &quot;$CurrentDate
  AuthHeader=&quot;X-Amzn-Authorization: AWS3-HTTPS AWSAccessKeyId=$AmazonID,Algorithm=HmacSHA1,Signature=$Signature&quot;

  # Submit request
  Result=$(wget -nv --header=&quot;$DateHeader&quot; --header=&quot;$AuthHeader&quot; --header=&quot;Content-Type: text/xml; charset=UTF-8&quot; --post-data=&quot;$Changeset&quot; -O /dev/stdout -o /dev/stdout https://route53.amazonaws.com/2010-10-01/hostedzone/$ZoneID/rrset)

  if [ &quot;$?&quot; -ne &quot;0&quot; ]; then
    echo &quot;Failed to update $Hostname.$Domain: &quot;$Result
  fi
fi</code></pre></noscript></div>

]]></content>
  </entry>
  
</feed>
