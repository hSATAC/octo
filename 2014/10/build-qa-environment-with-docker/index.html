
<!DOCTYPE HTML>

<html>

<head>
	<meta charset="utf-8">
	<title>使用 Docker 建置 QA 環境 - hSATAC</title>
	<meta name="author" content="Ash Wu">

	
	<meta name="description" content="Oct 18th, 2014 Docker 使用 Docker 建置 QA 環境 這篇是延續上一篇《整合 Jenkins 和 Docker》，使用 Docker 來建置 QA 環境的想法。 在上一篇有提到，原本的設計是當 Github 收到 Pull Request 時，就讓 Jenkins &hellip;">
	

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="http://feeds.feedburner.com/hsatac" rel="alternate" title="hSATAC" type="application/atom+xml">
	
	<link rel="canonical" href="http://blog.hsatac.net/2014/10/build-qa-environment-with-docker/">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<link href='http://fonts.googleapis.com/css?family=Open+Sans:400italic,400,700' rel='stylesheet' type='text/css'>
	<!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<!-- Add jQuery library -->
<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
<script type="text/javascript" src="/javascripts/jquery.fancybox.pack.js?v=2.0.4"></script>
<script type="text/javascript">
  $(document).ready(function() {
      $("a[href$='.jpg'],a[href$='.png'],a[href$='.gif']").fancybox();
  });
</script>

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
			<header id="header" class="inner"><div class="profilepic">
	<script src="/javascripts/md5.js"></script>
	<script type="text/javascript">
		$(function(){
			$('.profilepic').append("<img src='http://www.gravatar.com/avatar/" + MD5("hsatac@gmail.com") + "?s=160' alt='Profile Picture' style='width: 160px;' />");
		});
	</script>
</div>
<hgroup>
  <h1><a href="/">hSATAC</a></h1>
  
</hgroup>

<nav id="main-nav"><ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="http://blog.ash.cat">Hobbies</a></li>
</ul>


<section class="aboutme">
  <p>
    I am a programming language user. Here are some breadcrumbs of my work and life.
 >> ('cat' + 'ash').reverse #=> "hsatac"
  </p>
</section>
</nav>
<nav id="sub-nav">
	<div class="social">
		
		<a class="facebook" href="http://www.facebook.com/hSATAC" title="Facebook">Facebook</a>
		
		
		<a class="google" href="https://plus.google.com/113141223333997550446" rel="author" title="Google+">Google+</a>
		
		
		<a class="twitter" href="http://twitter.com/hSATAC" title="Twitter">Twitter</a>
		
		
		<a class="github" href="https://github.com/hSATAC" title="GitHub">GitHub</a>
		
		
		
		
		<a class="linkedin" href="http://www.linkedin.com/in/hSATAC" title="LinkedIn">LinkedIn</a>
		
		
		
		<a class="delicious" href="http://delicious.com/cat" title="Delicious">Delicious</a>
		
		
		
		<a class="rss" href="http://feeds.feedburner.com/hsatac" title="RSS">RSS</a>
		
	</div>
</nav>
</header>				
			</div>
		</div>	
		<div class="mid-col">
			
				
			
			<div class="mid-col-container">
				<div id="content" class="inner"><article class="post" itemscope itemtype="http://schema.org/BlogPosting">
    <div class="meta">
        <div class="date">








  


<time datetime="2014-10-18T16:58:00+08:00" data-updated="true" itemprop="datePublished">Oct 18<span>th</span>, 2014</time></div>
        <div class="tags">


	<a class='category' href='/categories/docker/'>Docker</a>


</div>
    </div>
	<h1 class="title" itemprop="name">使用 Docker 建置 QA 環境</h1>
	<div class="entry-content" itemprop="articleBody"><p>這篇是延續上一篇<a href="/2014/06/working-with-docker-and-jenkins/">《整合 Jenkins 和 Docker》</a>，使用 Docker 來建置 QA 環境的想法。</p>

<p>在上一篇有提到，原本的設計是當 Github 收到 Pull Request 時，就讓 Jenkins 來跑測試，如果測試通過，就直接用原本建置出來的 docker image 建立起一個 QA 環境，這樣就可以直接透過連到 <code>&lt;ticket-number&gt;.qa.domain.internal</code> 的方式來驗收，確定無誤後再按下 merge 按鈕，然後 trigger 自動關閉此 QA 環境。</p>

<p>不過後來因為這個情境不適合我們的 workflow, 所以最後沒有這樣實做。而是寫成 rake task 來運用。</p>

<!-- more -->


<p>具體的方式是，把整個 docker 中的 app 目錄 mount 出來，然後 nginx 透過 subdomain  來決定 app root 和 proxy_pass backend. 由於可能會有許多 qa 環境同時存在，要弄轉 port 還挺麻煩的，所以這邊都使用 unix domain socket.</p>

<h2>Nginx</h2>

<p>先來看一下 nginx 這邊的設定，其實很單純，簡化過後大概就長這樣：</p>

<div><script src='https://gist.github.com/fba5950eec5e90385015.js?file=nginx.conf'></script>
<noscript><pre><code>server {
        listen       80;
        server_name  &quot;~^(?&lt;sub&gt;.+)\.qa\.domain\.internal$&quot; &quot;~^(.+)\.(?&lt;sub&gt;.+)\.qa-cc\.domain\.internal$&quot;;
        root /var/www/qa/$sub/appname/public;
        charset utf-8;
        try_files $uri/index.html $uri.html $uri @app;
        location @app {
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header Host $http_host;
                proxy_redirect off;
                proxy_pass http://unix:/var/www/qa/$sub/appname/puma.sock;
                error_page 502 /qa_404.html; # Does not exist.
        }
        location ~* ^\/(images|javascripts)\/.*\.(ico|css|js|gif|jpe?g|png)(\?[0-9]+)?$  {
                expires max;
                break;
        }
}</code></pre></noscript></div>


<p>這樣透過 <code>newfeature.qa.domain.internal</code> 就可以連到從 docker 裡面 mount 出來到 <code>/var/www/newfeature</code> 這個目錄的靜態檔案和 unix domain socket.</p>

<h2>Makefile</h2>

<p>Makefile 是用來 build docker image, 這部分做的事情大致上是切到一個 workspace 目錄，此目錄是我 app 的 git repo, 然後切到我要建置的 QA branch 後開始 build docker image.</p>

<div><script src='https://gist.github.com/fba5950eec5e90385015.js?file=Makefile'></script>
<noscript><pre><code>all: base gem test qa
base:
    docker build --rm --no-cache -t myapp/base base
gem: fetch_workspace
    rm -f gem/*
    cp workspace/myapp/Gemfile* gem/
test:
    cp -R gem test/
    docker build --rm --no-cache -t myapp/test test
    rm -rf test/gem
qa:
    cp -R gem qa/
    docker build --rm --no-cache -t myapp/qa qa
    rm -rf qa/gem
clean_workspace:
    cd workspace/myapp;\
    git clean -f;\
    git reset --hard HEAD
fetch_workspace: clean_workspace
    cd workspace/myapp;\
    git fetch;\
    git checkout master;\
    git pull
qa_branch:
ifdef QA_BRANCH
    $(info ******* Start building branch ${QA_BRANCH} for name ${QA_DOMAIN} ********)
    # Check out the branch
    cd workspace/myapp;\
    git clean -f;\
    git reset --hard HEAD;\
    git fetch;\
    git checkout ${QA_BRANCH};\
    git pull
    # Copy required files
    cp -r qa/config/* workspace/myapp/config/
    # use sed to replace some config in config/*.yml here.
    cp qa/*.sh workspace/myapp/
    echo &quot;FROM myapp/qa&quot; &gt; workspace/myapp/Dockerfile
    # Store branch and domain name into files
    echo &quot;${QA_DOMAIN}&quot; &gt; workspace/myapp/qa_domain
    echo &quot;${QA_BRANCH}&quot; &gt; workspace/myapp/qa_branch
    # Build
    docker build --rm -t myapp_qa/${QA_DOMAIN} workspace/myapp/
    # Clean
    cd workspace/myapp;\
    git clean -f;\
    git reset --hard HEAD;\
    git checkout master
else
    $(info ******* Please specify QA_BRANCH ********)
endif
.PHONY: all base test qa qa_branch gem</code></pre></noscript></div>


<p>gem 的部分再上一篇有提過，預先安裝 gem 是為了加速整個建置的過程，這邊會丟到 crontab 每天晚上自動執行更新。</p>

<p>執行 <code>make qa_branch QA_BRANCH=master QA_DOMAIN=master</code> 即可建置出特定 branch 的 docker image.</p>

<p>可以看到我直接把 branch name 和 domain name 寫到 app 資料夾中，這樣就不用資料庫來紀錄什麼 domain name 對應什麼 branch 了。</p>

<p>這邊需要注意由於 domain name 用在三個地方：</p>

<ol>
<li>domain</li>
<li>路徑</li>
<li>docker image name</li>
</ol>


<p>比較麻煩的是 domain name 只能有 <code>-</code> 不能有 <code>_</code>, 而 docker image name 則剛好相反，不能有 <code>-</code> 只能有 <code>_</code> 所以在輸入名稱的時候要特別注意。由於我外面是包 messaging bot 來下指令，那邊有做檢查，所以這邊就沒有另外再做檢查。</p>

<h2>Rakefile</h2>

<p>Rakefile 是拿來啟動 / 關閉 QA 環境用的。</p>

<div><script src='https://gist.github.com/fba5950eec5e90385015.js?file=Rakefile'></script>
<noscript><pre><code>require &#39;yaml&#39;
require &#39;docker&#39;
require &#39;pty&#39;
require &#39;slack-notifier&#39;

Docker.url = &quot;tcp://127.0.0.1:4243&quot;

QA_DIR = &quot;/var/www/qa&quot;

QA_URL = &quot;qa.domain.internal&quot;

QA_IMAGE_REGEX = /myapp_qa\/(\w+):latest/

ROOT_PATH = File.dirname(__FILE__)

desc &quot;List running containers&quot;
task :running do
    puts `docker ps`
end

desc &quot;Clean stopped containers&quot;
task :remove_stopped_containers do
    puts &quot;----- Cleaning stopped containers -----&quot;
    puts `#{ROOT_PATH}/bin/remove_stopped_containers.sh`
end

namespace :qa do
    desc &quot;List all running QA containers&quot;
    task :list do
        running_qa_domains = qa_running_containers.map {|c| c.info[&quot;Image&quot;].match(QA_IMAGE_REGEX)[1]}
        puts &quot;----- Current QA containers -----&quot;
        running_qa_domains.each do |domain|
            puts &quot;http://#{domain}.#{QA_URL} (#{`cat #{QA_DIR}/#{domain}/myapp/qa_branch`.strip})&quot;
        end
    end

    desc &quot;Build and start a QA container&quot;
    task :start, [:branch_name, :domain_name] do |t, args|
        branch_name = args[:branch_name]
        domain_name = args[:domain_name]
        hipchat_notify(&quot;Start to build QA container *myapp_qa/#{domain_name}* for :branch: *#{branch_name}*&quot;)
        puts &quot;----- Building QA container myapp_qa/#{domain_name} for branch #{branch_name}&quot;
        pipe_exec &quot;cd #{ROOT_PATH} &amp;&amp; make qa_branch QA_BRANCH=#{branch_name} QA_DOMAIN=#{domain_name}&quot;
        puts &quot;----- Starting QA container myapp_qa/#{domain_name} for branch #{branch_name}&quot;
        puts `sudo rm -rf #{QA_DIR}/#{domain_name}` # Remove workspace if it existed
        pipe_exec &quot;docker run -d -i -t -v #{QA_DIR}/#{domain_name}:/opt/run:rw --privileged myapp_qa/#{domain_name}&quot;
        puts &quot;----- Running and initializing fake data and indexes... -----&quot;
        
        status_file = &quot;#{QA_DIR}/#{domain_name}/myapp/status&quot;
        status = &quot;init&quot;
        loop do # Loop until ready.
            if File.exists?(status_file)
                current_status = File.read(status_file).strip
                break if current_status == &quot;ready&quot;
                if status != current_status
                    puts &quot;#### Status changed from #{status} to #{current_status} ####&quot;
                    status = current_status
                end
            end
            sleep 5
        end 
        puts &quot;=====&gt; http://#{domain_name}.#{QA_URL} &lt;=====&quot;
        hipchat_notify(&quot;QA environment for :branch: *#{branch_name}* is ready at http://#{domain_name}.#{QA_URL}&quot;)
    end

    desc &quot;Stop QA container&quot;
    task :stop, [:domain_name] do |t, args|
    domain_name = args[:domain_name]
        container = nil
        Docker::Container.all.each do |c| 
            container = c if c.info[&quot;Image&quot;] == &quot;myapp_qa/#{domain_name}:latest&quot;
        end
        if container
            puts &quot;----- Stopping QA container #{domain_name} -----&quot;
            puts container.stop
            puts &quot;----- Deleting QA container #{domain_name} -----&quot;
            puts container.delete
            puts &quot;----- Deleting QA workspace #{domain_name} -----&quot;
            puts `sudo rm -rf #{QA_DIR}/#{domain_name}`
            puts &quot;----- Deleting QA image myapp_qa/#{domain_name} -----&quot;
            puts `docker rmi myapp_qa/#{domain_name}`
            puts &quot;----- Done. -----&quot;
        else
            puts &quot;There&#39;s no running QA container of domain #{domain_name}&quot;
        end
    end

    desc &quot;Clean stopped container and remove unused workspaces.&quot;
    task :clean do
        Rake::Task[&quot;remove_stopped_containers&quot;].invoke

        running_qa_domains = qa_running_containers.map {|c| c.info[&quot;Image&quot;].match(QA_IMAGE_REGEX)[1]}
        puts &quot;----- Deleting unused QA images -----&quot;
        qa_images.map do |image|
            unless running_qa_domains.include?(image.info[&quot;RepoTags&quot;].first.match(QA_IMAGE_REGEX)[1])
                puts &quot;Image #{image.info[&quot;RepoTags&quot;].first} removed.&quot;
                image.remove 
            end
        end
        puts &quot;----- Cleaning stopped QA workspaces -----&quot;
        Dir.glob(&quot;#{QA_DIR}/*&quot;).each do |f|
            unless running_qa_domains.include?(File.basename(f))
                puts `sudo rm -rf #{f}` 
            end
        end
            
    end
end

######## Helpers ########
#
def pipe_exec(command)
  begin
    PTY.spawn(command) do |stdin, stdout, pid|
      begin
        stdin.each { |line| print line }
      rescue Errno::EIO
      end
    end
  rescue PTY::ChildExited
    puts &quot;The child process exited!&quot;
  end
end

def qa_running_containers
    Docker::Container.all.select {|c| c.info[&quot;Image&quot;] =~ QA_IMAGE_REGEX }
end

def qa_images
    Docker::Image.all.select { |c| c.info[&quot;RepoTags&quot;].first =~ QA_IMAGE_REGEX }
end

def hipchat_notify(msg)
    config = YAML.load_file(&#39;config/config.yml&#39;)
    return if config[&#39;slack_token&#39;] == nil || config[&#39;slack_token&#39;] == &quot;&quot;
    notifier = Slack::Notifier.new &quot;kkbox&quot;, config[&#39;slack_token&#39;], channel: &#39;#myapp&#39;, username: &#39;Docker&#39;
    notifier.ping msg, icon_emoji: &quot;:myapp:&quot;
end
</code></pre></noscript></div>


<p>這邊值得一提的是，由於 container build 好，到整個 service run 起來其實還有一段時間差，是用來啟動 service, initial db 等等動作&hellip;所以在 app 目錄下會寫一個 <code>status</code> file 來判斷現在 app initial 到什麼階段，等他變成 <code>ready</code> 後才判斷為建置完成。</p>

<h2>start_rails.sh</h2>

<p>這是 QA docker image run 起來後會執行的 script, 比較重要的有兩個部分，一個是上面提的把目前階段寫入 <code>status</code> 檔案，讓外面知道現在進行到什麼步驟；另一個則是使用 <a href="http://www.dest-unreach.org/socat/">socat</a> 把 port 轉為 unix domain socket 再 mount 出去，就可以讓外面的 nginx 跟 docker 內部的 web services 溝通，而不需要處理 docker 的 port 了。</p>

<p>把 8080 port 轉到 <code>/opt/run/myapp/go.sock</code>：</p>

<p><code>socat UNIX-LISTEN:/opt/run/myapp/go.sock,reuseaddr,fork TCP:localhost:8080</code></p>

<div><script src='https://gist.github.com/fba5950eec5e90385015.js?file=start_rails.sh'></script>
<noscript><pre><code>echo &quot;dev:fake&quot; &gt; /opt/run/myapp/status
cd /opt/run/myapp &amp;&amp; rvm all do bundle exec rake dev:build
cd /opt/run/myapp &amp;&amp; rvm all do bundle exec rake dev:load
cd /opt/run/myapp &amp;&amp; rvm all do unicorn_rails -c config/unicorn.rb -D

echo &quot;building golang&quot; &gt; /opt/run/myapp/status
if [ -d &quot;/opt/run/myapp/go&quot; ]; then
    #cd /opt/run/myapp/go &amp;&amp; gom install # This takes some time.
    cd /opt/run/myapp/go &amp;&amp; ./make build
    cd /opt/run/myapp/go &amp;&amp; ./kktix_go start -d
    socat UNIX-LISTEN:/opt/run/myapp/go.sock,reuseaddr,fork TCP:localhost:8080 &amp;
fi

echo &quot;sidekiq&quot; &gt; /opt/run/myapp/status
cd /opt/run/myapp &amp;&amp; rvm all do bundle exec sidekiq -c 5 -d -L log/sidekiq.log &amp;
cd /opt/run/myapp &amp;&amp; rvm all do ruby -rsidekiq/api -e &#39;loop do;count = Sidekiq::Stats.new.enqueued;puts &quot;Remaining jobs: #{count}&quot;;if count == 0;`echo &quot;ready&quot; &gt; /opt/run/kktix/status`;break;end;sleep 5;end&#39;

if [ -e &quot;/opt/run/myapp/go.sock&quot; ]; then
    chmod 777 /opt/run/myapp/go.sock
fi

cd /opt/run/myapp &amp;&amp; /bin/bash
</code></pre></noscript></div>


<h2>Conclusion</h2>

<p>這篇的 scripts 有點繁雜，不過概念其實很簡單，只是細節上有不少需要注意的地方。</p>

<p>使用 docker 來建置 QA branch 可以方便快速的建出乾淨的環境，相較以往要處理非常多資料庫 / 轉 port / services isolation 等等問題，實在是輕鬆太多了。</p>
</div>

</article>

	<div class="share">
	<div class="addthis_toolbox addthis_default_style ">
	
	<a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
	
	
	<a class="addthis_button_tweet"></a>
	
	
	<a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
	
	<a class="addthis_counter addthis_pill_style"></a>
	</div>
  <script type="text/javascript" src="http://s7.addthis.com/js/250/addthis_widget.js#pubid="></script>
</div>



<section id="comment">
    <h1 class="title">Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
</section>
</div>
			</div>
			<footer id="footer" class="inner"><p>
  Copyright &copy; 2014 - Ash Wu -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span> - Logo authorized by <a href="http://www3.ocn.ne.jp/~musimaru/">64CAT64</a>
</p>

Design credit: <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a></footer>
			<script src="/javascripts/slash.js"></script>


<script type="text/javascript">
      var disqus_shortname = 'hsatac';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://blog.hsatac.net/2014/10/build-qa-environment-with-docker/';
        var disqus_url = 'http://blog.hsatac.net/2014/10/build-qa-environment-with-docker/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-27441833-1']);
		_gaq.push(['_trackPageview']);

		(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>





		</div>
	</div>
</body>
</html>
