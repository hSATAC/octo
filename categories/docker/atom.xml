<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: docker | hSATAC]]></title>
  <link href="http://blog.hsatac.net/categories/docker/atom.xml" rel="self"/>
  <link href="http://blog.hsatac.net/"/>
  <updated>2014-10-21T00:21:20+08:00</updated>
  <id>http://blog.hsatac.net/</id>
  <author>
    <name><![CDATA[Ash Wu]]></name>
    <email><![CDATA[hsatac@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用 Docker 建置 QA 環境]]></title>
    <link href="http://blog.hsatac.net/2014/10/build-qa-environment-with-docker/"/>
    <updated>2014-10-18T16:58:00+08:00</updated>
    <id>http://blog.hsatac.net/2014/10/build-qa-environment-with-docker</id>
    <content type="html"><![CDATA[<p>這篇是延續上一篇<a href="/2014/06/working-with-docker-and-jenkins/">《整合 Jenkins 和 Docker》</a>，使用 Docker 來建置 QA 環境的想法。</p>

<p>在上一篇有提到，原本的設計是當 Github 收到 Pull Request 時，就讓 Jenkins 來跑測試，如果測試通過，就直接用原本建置出來的 docker image 建立起一個 QA 環境，這樣就可以直接透過連到 <code>&lt;ticket-number&gt;.qa.domain.internal</code> 的方式來驗收，確定無誤後再按下 merge 按鈕，然後 trigger 自動關閉此 QA 環境。</p>

<p>不過後來因為這個情境不適合我們的 workflow, 所以最後沒有這樣實做。而是寫成 rake task 來運用。</p>

<!-- more -->


<p>具體的方式是，把整個 docker 中的 app 目錄 mount 出來，然後 nginx 透過 subdomain  來決定 app root 和 proxy_pass backend. 由於可能會有許多 qa 環境同時存在，要弄轉 port 還挺麻煩的，所以這邊都使用 unix domain socket.</p>

<h2>Nginx</h2>

<p>先來看一下 nginx 這邊的設定，其實很單純，簡化過後大概就長這樣：</p>

<p><div><script src='https://gist.github.com/fba5950eec5e90385015.js?file=nginx.conf'></script>
<noscript><pre><code>server {
        listen       80;
        server_name  &quot;~^(?&lt;sub&gt;.+)\.qa\.domain\.internal$&quot; &quot;~^(.+)\.(?&lt;sub&gt;.+)\.qa-cc\.domain\.internal$&quot;;
        root /var/www/qa/$sub/appname/public;
        charset utf-8;
        try_files $uri/index.html $uri.html $uri @app;
        location @app {
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header Host $http_host;
                proxy_redirect off;
                proxy_pass http://unix:/var/www/qa/$sub/appname/puma.sock;
                error_page 502 /qa_404.html; # Does not exist.
        }
        location ~* ^\/(images|javascripts)\/.*\.(ico|css|js|gif|jpe?g|png)(\?[0-9]+)?$  {
                expires max;
                break;
        }
}</code></pre></noscript></div>
</p>

<p>這樣透過 <code>newfeature.qa.domain.internal</code> 就可以連到從 docker 裡面 mount 出來到 <code>/var/www/newfeature</code> 這個目錄的靜態檔案和 unix domain socket.</p>

<h2>Makefile</h2>

<p>Makefile 是用來 build docker image, 這部分做的事情大致上是切到一個 workspace 目錄，此目錄是我 app 的 git repo, 然後切到我要建置的 QA branch 後開始 build docker image.</p>

<p><div><script src='https://gist.github.com/fba5950eec5e90385015.js?file=Makefile'></script>
<noscript><pre><code>all: base gem test qa
base:
	docker build --rm --no-cache -t myapp/base base
gem: fetch_workspace
	rm -f gem/*
	cp workspace/myapp/Gemfile* gem/
test:
	cp -R gem test/
	docker build --rm --no-cache -t myapp/test test
	rm -rf test/gem
qa:
	cp -R gem qa/
	docker build --rm --no-cache -t myapp/qa qa
	rm -rf qa/gem
clean_workspace:
	cd workspace/myapp;\
	git clean -f;\
	git reset --hard HEAD
fetch_workspace: clean_workspace
	cd workspace/myapp;\
	git fetch;\
	git checkout master;\
	git pull
qa_branch:
ifdef QA_BRANCH
	$(info ******* Start building branch ${QA_BRANCH} for name ${QA_DOMAIN} ********)
	# Check out the branch
	cd workspace/myapp;\
	git clean -f;\
	git reset --hard HEAD;\
	git fetch;\
	git checkout ${QA_BRANCH};\
	git pull
	# Copy required files
	cp -r qa/config/* workspace/myapp/config/
	# use sed to replace some config in config/*.yml here.
	cp qa/*.sh workspace/myapp/
	echo &quot;FROM myapp/qa&quot; &gt; workspace/myapp/Dockerfile
	# Store branch and domain name into files
	echo &quot;${QA_DOMAIN}&quot; &gt; workspace/myapp/qa_domain
	echo &quot;${QA_BRANCH}&quot; &gt; workspace/myapp/qa_branch
	# Build
	docker build --rm -t myapp_qa/${QA_DOMAIN} workspace/myapp/
	# Clean
	cd workspace/myapp;\
	git clean -f;\
	git reset --hard HEAD;\
	git checkout master
else
	$(info ******* Please specify QA_BRANCH ********)
endif
.PHONY: all base test qa qa_branch gem</code></pre></noscript></div>
</p>

<p>gem 的部分再上一篇有提過，預先安裝 gem 是為了加速整個建置的過程，這邊會丟到 crontab 每天晚上自動執行更新。</p>

<p>執行 <code>make qa_branch QA_BRANCH=master QA_DOMAIN=master</code> 即可建置出特定 branch 的 docker image.</p>

<p>可以看到我直接把 branch name 和 domain name 寫到 app 資料夾中，這樣就不用資料庫來紀錄什麼 domain name 對應什麼 branch 了。</p>

<p>這邊需要注意由於 domain name 用在三個地方：</p>

<ol>
<li>domain</li>
<li>路徑</li>
<li>docker image name</li>
</ol>


<p>比較麻煩的是 domain name 只能有 <code>-</code> 不能有 <code>_</code>, 而 docker image name 則剛好相反，不能有 <code>-</code> 只能有 <code>_</code> 所以在輸入名稱的時候要特別注意。由於我外面是包 messaging bot 來下指令，那邊有做檢查，所以這邊就沒有另外再做檢查。</p>

<h2>Rakefile</h2>

<p>Rakefile 是拿來啟動 / 關閉 QA 環境用的。</p>

<p><div><script src='https://gist.github.com/fba5950eec5e90385015.js?file=Rakefile'></script>
<noscript><pre><code>require &#39;yaml&#39;
require &#39;docker&#39;
require &#39;pty&#39;
require &#39;slack-notifier&#39;

Docker.url = &quot;tcp://127.0.0.1:4243&quot;

QA_DIR = &quot;/var/www/qa&quot;

QA_URL = &quot;qa.domain.internal&quot;

QA_IMAGE_REGEX = /myapp_qa\/(\w+):latest/

ROOT_PATH = File.dirname(__FILE__)

desc &quot;List running containers&quot;
task :running do
	puts `docker ps`
end

desc &quot;Clean stopped containers&quot;
task :remove_stopped_containers do
	puts &quot;----- Cleaning stopped containers -----&quot;
	puts `#{ROOT_PATH}/bin/remove_stopped_containers.sh`
end

namespace :qa do
	desc &quot;List all running QA containers&quot;
	task :list do
		running_qa_domains = qa_running_containers.map {|c| c.info[&quot;Image&quot;].match(QA_IMAGE_REGEX)[1]}
		puts &quot;----- Current QA containers -----&quot;
		running_qa_domains.each do |domain|
			puts &quot;http://#{domain}.#{QA_URL} (#{`cat #{QA_DIR}/#{domain}/myapp/qa_branch`.strip})&quot;
		end
	end

	desc &quot;Build and start a QA container&quot;
	task :start, [:branch_name, :domain_name] do |t, args|
		branch_name = args[:branch_name]
		domain_name = args[:domain_name]
		hipchat_notify(&quot;Start to build QA container *myapp_qa/#{domain_name}* for :branch: *#{branch_name}*&quot;)
		puts &quot;----- Building QA container myapp_qa/#{domain_name} for branch #{branch_name}&quot;
		pipe_exec &quot;cd #{ROOT_PATH} &amp;&amp; make qa_branch QA_BRANCH=#{branch_name} QA_DOMAIN=#{domain_name}&quot;
		puts &quot;----- Starting QA container myapp_qa/#{domain_name} for branch #{branch_name}&quot;
		puts `sudo rm -rf #{QA_DIR}/#{domain_name}` # Remove workspace if it existed
		pipe_exec &quot;docker run -d -i -t -v #{QA_DIR}/#{domain_name}:/opt/run:rw --privileged myapp_qa/#{domain_name}&quot;
		puts &quot;----- Running and initializing fake data and indexes... -----&quot;
		
		status_file = &quot;#{QA_DIR}/#{domain_name}/myapp/status&quot;
		status = &quot;init&quot;
		loop do # Loop until ready.
			if File.exists?(status_file)
				current_status = File.read(status_file).strip
				break if current_status == &quot;ready&quot;
				if status != current_status
					puts &quot;#### Status changed from #{status} to #{current_status} ####&quot;
					status = current_status
				end
			end
			sleep 5
 		end	
		puts &quot;=====&gt; http://#{domain_name}.#{QA_URL} &lt;=====&quot;
		hipchat_notify(&quot;QA environment for :branch: *#{branch_name}* is ready at http://#{domain_name}.#{QA_URL}&quot;)
	end

	desc &quot;Stop QA container&quot;
	task :stop, [:domain_name] do |t, args|
	domain_name = args[:domain_name]
		container = nil
		Docker::Container.all.each do |c| 
			container = c if c.info[&quot;Image&quot;] == &quot;myapp_qa/#{domain_name}:latest&quot;
		end
		if container
			puts &quot;----- Stopping QA container #{domain_name} -----&quot;
			puts container.stop
			puts &quot;----- Deleting QA container #{domain_name} -----&quot;
			puts container.delete
			puts &quot;----- Deleting QA workspace #{domain_name} -----&quot;
			puts `sudo rm -rf #{QA_DIR}/#{domain_name}`
			puts &quot;----- Deleting QA image myapp_qa/#{domain_name} -----&quot;
			puts `docker rmi myapp_qa/#{domain_name}`
			puts &quot;----- Done. -----&quot;
		else
			puts &quot;There&#39;s no running QA container of domain #{domain_name}&quot;
		end
	end

	desc &quot;Clean stopped container and remove unused workspaces.&quot;
	task :clean do
		Rake::Task[&quot;remove_stopped_containers&quot;].invoke

		running_qa_domains = qa_running_containers.map {|c| c.info[&quot;Image&quot;].match(QA_IMAGE_REGEX)[1]}
		puts &quot;----- Deleting unused QA images -----&quot;
		qa_images.map do |image|
			unless running_qa_domains.include?(image.info[&quot;RepoTags&quot;].first.match(QA_IMAGE_REGEX)[1])
				puts &quot;Image #{image.info[&quot;RepoTags&quot;].first} removed.&quot;
				image.remove 
			end
		end
		puts &quot;----- Cleaning stopped QA workspaces -----&quot;
		Dir.glob(&quot;#{QA_DIR}/*&quot;).each do |f|
			unless running_qa_domains.include?(File.basename(f))
				puts `sudo rm -rf #{f}`	
			end
		end
			
	end
end

######## Helpers ########
#
def pipe_exec(command)
  begin
    PTY.spawn(command) do |stdin, stdout, pid|
      begin
        stdin.each { |line| print line }
      rescue Errno::EIO
      end
    end
  rescue PTY::ChildExited
    puts &quot;The child process exited!&quot;
  end
end

def qa_running_containers
	Docker::Container.all.select {|c| c.info[&quot;Image&quot;] =~ QA_IMAGE_REGEX }
end

def qa_images
	Docker::Image.all.select { |c| c.info[&quot;RepoTags&quot;].first =~ QA_IMAGE_REGEX }
end

def hipchat_notify(msg)
	config = YAML.load_file(&#39;config/config.yml&#39;)
	return if config[&#39;slack_token&#39;] == nil || config[&#39;slack_token&#39;] == &quot;&quot;
	notifier = Slack::Notifier.new &quot;kkbox&quot;, config[&#39;slack_token&#39;], channel: &#39;#myapp&#39;, username: &#39;Docker&#39;
	notifier.ping msg, icon_emoji: &quot;:myapp:&quot;
end
</code></pre></noscript></div>
</p>

<p>這邊值得一提的是，由於 container build 好，到整個 service run 起來其實還有一段時間差，是用來啟動 service, initial db 等等動作&hellip;所以在 app 目錄下會寫一個 <code>status</code> file 來判斷現在 app initial 到什麼階段，等他變成 <code>ready</code> 後才判斷為建置完成。</p>

<h2>start_rails.sh</h2>

<p>這是 QA docker image run 起來後會執行的 script, 比較重要的有兩個部分，一個是上面提的把目前階段寫入 <code>status</code> 檔案，讓外面知道現在進行到什麼步驟；另一個則是使用 <a href="http://www.dest-unreach.org/socat/">socat</a> 把 port 轉為 unix domain socket 再 mount 出去，就可以讓外面的 nginx 跟 docker 內部的 web services 溝通，而不需要處理 docker 的 port 了。</p>

<p>把 8080 port 轉到 <code>/opt/run/myapp/go.sock</code>：</p>

<p><code>socat UNIX-LISTEN:/opt/run/myapp/go.sock,reuseaddr,fork TCP:localhost:8080</code></p>

<p><div><script src='https://gist.github.com/fba5950eec5e90385015.js?file=start_rails.sh'></script>
<noscript><pre><code>echo &quot;dev:fake&quot; &gt; /opt/run/myapp/status
cd /opt/run/myapp &amp;&amp; rvm all do bundle exec rake dev:build
cd /opt/run/myapp &amp;&amp; rvm all do bundle exec rake dev:load
cd /opt/run/myapp &amp;&amp; rvm all do unicorn_rails -c config/unicorn.rb -D

echo &quot;building golang&quot; &gt; /opt/run/myapp/status
if [ -d &quot;/opt/run/myapp/go&quot; ]; then
	#cd /opt/run/myapp/go &amp;&amp; gom install # This takes some time.
	cd /opt/run/myapp/go &amp;&amp; ./make build
	cd /opt/run/myapp/go &amp;&amp; ./kktix_go start -d
	socat UNIX-LISTEN:/opt/run/myapp/go.sock,reuseaddr,fork TCP:localhost:8080 &amp;
fi

echo &quot;sidekiq&quot; &gt; /opt/run/myapp/status
cd /opt/run/myapp &amp;&amp; rvm all do bundle exec sidekiq -c 5 -d -L log/sidekiq.log &amp;
cd /opt/run/myapp &amp;&amp; rvm all do ruby -rsidekiq/api -e &#39;loop do;count = Sidekiq::Stats.new.enqueued;puts &quot;Remaining jobs: #{count}&quot;;if count == 0;`echo &quot;ready&quot; &gt; /opt/run/kktix/status`;break;end;sleep 5;end&#39;

if [ -e &quot;/opt/run/myapp/go.sock&quot; ]; then
	chmod 777 /opt/run/myapp/go.sock
fi

cd /opt/run/myapp &amp;&amp; /bin/bash
</code></pre></noscript></div>
</p>

<h2>Conclusion</h2>

<p>這篇的 scripts 有點繁雜，不過概念其實很簡單，只是細節上有不少需要注意的地方。</p>

<p>使用 docker 來建置 QA branch 可以方便快速的建出乾淨的環境，相較以往要處理非常多資料庫 / 轉 port / services isolation 等等問題，實在是輕鬆太多了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[整合 Jenkins 和 Docker]]></title>
    <link href="http://blog.hsatac.net/2014/06/working-with-docker-and-jenkins/"/>
    <updated>2014-06-29T22:51:00+08:00</updated>
    <id>http://blog.hsatac.net/2014/06/working-with-docker-and-jenkins</id>
    <content type="html"><![CDATA[<p>這篇將會記述一些我自己整合 Jenkins CI 和 Docker 的思路、想法、要點以及備忘。不會有 step by step 的教學，若有此類需求請參考最後附錄。</p>

<h2>Why Docker?</h2>

<p>Jenkins 跑的好好的，為什麼要摻 Docker 呢？原本我們 Rails Rspec 跑的其實也不錯，但受限於 database 以及 elasticsearch, redis 等 services，無法同時跑多個 worker, 再加上未來若有平行化測試以及多個專案 / 不同 db 版本等等的需求，引入 docker 可以完美解決這些問題。</p>

<h2>Concept</h2>

<p>使用 Docker 的好處就是原本的 shell script 幾乎都不用改即可繼續使用，引入的門檻降到極低。</p>

<p>基本概念是建立一個可以跑 Rails app 起來的環境，然後把整個 CI 的 workspace 丟進去跑測試，其他的步驟都一模一樣。</p>

<p>在建立環境這邊基本上有兩個選擇，一種是全部包成一個 image, 就用這個 container 來跑測試。另一種是每個需要的 service 都是一個各自的 container, 彼此之間透過 <a href="https://docs.docker.com/userguide/dockerlinks/">Docker Container Linking</a> 來通訊，例如 postgresql 自己一個、elasticsearch 自己一個、rails 自己一個這樣。</p>

<p>不過由於跑測試都是用過即丟，這次我直接採用最簡單的包一大包的策略來進行，減少複雜度。</p>

<!--more-->


<p>我會選擇自己 Build docker 來跑測試主要是還想運用在其他地方，包括 trigger 不同的瀏覽器跑 feature tests 而不需重新 Build docker image 等等，如果沒有特殊需求的話也可以參考看看 Jenkins 的 <a href="https://wiki.jenkins-ci.org/display/JENKINS/Docker+Plugin">Docker Plugin</a> 基本概念是直接把 Jenkins slave 用 docker 跑起來。可以評估看看自己是否合用。</p>

<h3>Base Image</h3>

<p>我的設計是先建立一個 base image 例如給他 tag 叫 <code>project/base</code> 裡面先預裝好了所有環境包括 pg, elasticsearch, redis, rvm, ruby 等等。</p>

<p>舉例來說可能長這樣：</p>

<p>```
FROM ubuntu:12.04
MAINTAINER hSATAC</p>

<h1>We use bash</h1>

<p>RUN rm /bin/sh &amp;&amp; ln -s /bin/bash /bin/sh</p>

<h1>We don&rsquo;t like apt-get warnings.</h1>

<p>ENV DEBIAN_FRONTEND noninteractive</p>

<h1>Add the PostgreSQL PGP key to verify their Debian packages.</h1>

<h1>It should be the same key as <a href="https://www.postgresql.org/media/keys/ACCC4CF8.asc">https://www.postgresql.org/media/keys/ACCC4CF8.asc</a></h1>

<p>RUN apt-key adv &mdash;keyserver keyserver.ubuntu.com &mdash;recv-keys B97B0AFCAA1A47F044F244A07FCC7D46ACCC4CF8</p>

<h1>Add PostgreSQL&rsquo;s repository. It contains the most recent stable release</h1>

<h1>of PostgreSQL, <code>9.3</code>.</h1>

<p>RUN echo &ldquo;deb <a href="http://apt.postgresql.org/pub/repos/apt/">http://apt.postgresql.org/pub/repos/apt/</a> precise-pgdg main&rdquo; > /etc/apt/sources.list.d/pgdg.list</p>

<h1>Update the Ubuntu and PostgreSQL repository indexes</h1>

<p>RUN apt-get update</p>

<h1>=== Locale ===</h1>

<p>RUN locale-gen  en_US.UTF-8
ENV LANG en_US.UTF-8
ENV LANGUAGE en_US.UTF-8
ENV LC_ALL en_US.UTF-8</p>

<h1>=== Requirements ===</h1>

<p>RUN apt-get -y -q install nodejs libpq-dev wget git curl imagemagick vim postfix</p>

<p>RUN cd /tmp &amp;&amp;\</p>

<pre><code>wget http://downloads.sourceforge.net/project/wkhtmltopdf/0.12.0/wkhtmltox-linux-amd64_0.12.0-03c001d.tar.xz &amp;&amp;\
tar Jxvf wkhtmltox-linux-amd64_0.12.0-03c001d.tar.xz &amp;&amp;\
cd wkhtmltox &amp;&amp;\
install bin/wkhtmltoimage /usr/bin/wkhtmltoimage
</code></pre>

<h1>=== Redis ===</h1>

<p>RUN apt-get -y -q install redis-server</p>

<h1>=== Elasticsearch ===</h1>

<p>RUN apt-get install openjdk-7-jre-headless -y -q
RUN wget <a href="https://download.elasticsearch.org/elasticsearch/elasticsearch/elasticsearch-1.1.0.deb">https://download.elasticsearch.org/elasticsearch/elasticsearch/elasticsearch-1.1.0.deb</a>
RUN dpkg -i elasticsearch-1.1.0.deb</p>

<h1>=== RVM ===</h1>

<p>RUN curl -L <a href="https://get.rvm.io">https://get.rvm.io</a> | bash -s stable
ENV PATH /usr/local/rvm/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
RUN /bin/bash -l -c rvm requirements
RUN source /usr/local/rvm/scripts/rvm &amp;&amp; rvm install ruby-2.1.2
RUN rvm all do gem install bundler</p>

<h1>=== Postgresql ===</h1>

<p>RUN apt-get -y -q install python-software-properties software-properties-common
RUN apt-get -y -q install postgresql-9.3 postgresql-client-9.3 postgresql-contrib-9.3</p>

<h1>Update template1 to enable UTF-8 and hstore</h1>

<p>USER postgres
RUN    /etc/init.d/postgresql start &amp;&amp;\</p>

<pre><code>psql -c "update pg_database set datistemplate=false where datname='template1';" &amp;&amp;\
psql -c 'drop database Template1;' &amp;&amp;\
psql -c "create database template1 with owner=postgres encoding='UTF-8' lc_collate='en_US.utf8' lc_ctype='en_US.utf8' template template0;" &amp;&amp;\
psql -c 'CREATE EXTENSION hstore;' -d template1
</code></pre>

<h1>Create a PostgreSQL role and db</h1>

<p>RUN    /etc/init.d/postgresql start &amp;&amp;\</p>

<pre><code>psql --command "CREATE ROLE jenkins LOGIN PASSWORD 'jenkins' SUPERUSER INHERIT CREATEDB NOCREATEROLE NOREPLICATION;" &amp;&amp;\
createdb -O jenkins jenkins_test &amp;&amp;\
createdb -O jenkins jenkins_production
</code></pre>

<h1>Adjust PostgreSQL configuration</h1>

<p>RUN echo &ldquo;local all  all  md5&rdquo; > /etc/postgresql/9.3/main/pg_hba.conf</p>

<h1>And add <code>listen_addresses</code> to <code>/etc/postgresql/9.3/main/postgresql.conf</code></h1>

<p>RUN echo &ldquo;listen_addresses=&lsquo;*&rsquo;&rdquo; >> /etc/postgresql/9.3/main/postgresql.conf
```</p>

<h3>Test Image</h3>

<p>接著用 <code>project/base</code> build 一個 <code>project/test</code>，這個 image 會安裝一些「只有測試會用到」的套件，順便把 Gemfile 複製進去安裝一下 Gem, 這樣到時在跑測試的時候就可以省略 <code>bundle install</code> 的時間了。因為我的 base image 還有打算拿來做其他用途，所以這邊是這樣設計。</p>

<p>每天凌晨三點左右用 crontab 重新 Build 一次這個 <code>project/test</code> 的 image 以更新 gems. 當然這邊牽涉到一些如何同步你專案中的 Gemfile 不過這都是簡單的 script 可以解決的問題，這邊不贅述。</p>

<p>```
FROM project/base</p>

<h1>Switch back to root</h1>

<p>USER root</p>

<h1>Set ENV</h1>

<p>ENV RAILS_ENV test</p>

<h1>Preinstall gem</h1>

<p>ADD gem /opt/project_gem # 這個 gem 目錄裡面有 Gemfile 和 Gemfile.lock
WORKDIR /opt/project_gem
RUN rvm all do bundle install</p>

<h1>Install Firefox &amp; Xvfb</h1>

<p>RUN apt-get -y install firefox xvfb # 跑 selenium test 用的</p>

<h1>Onbuild witch back to root</h1>

<p>ONBUILD USER root</p>

<h1>Mound Rails directory</h1>

<p>ONBUILD ADD . /opt/project
ONBUILD WORKDIR /opt/project</p>

<h1>Bundle install</h1>

<p>ONBUILD RUN rvm all do bundle install</p>

<h1>Go</h1>

<p>ONBUILD ADD start_services.sh /opt/project/start_services.sh
ONBUILD RUN chmod +x /opt/project/start_services.sh
ONBUILD ADD run_tests.sh /opt/project/run_tests.sh
ONBUILD RUN chmod +x /opt/project/run_tests.sh
ONBUILD CMD /opt/project/start_services.sh &amp;&amp; /opt/project/run_tests.sh
```</p>

<p>注意這邊最後一段用到了上一篇文章 <a href="/2014/06/docker-basics/">Docker Basics</a> 中所講到的 ONBUILD, 使用這個功能我們就可以很輕鬆的 build 出真正用來測試的 Image.</p>

<p>這幾行實際做的動作是複製兩個 scripts 分別名叫 <code>start_services.sh</code> 和 <code>run_tests.sh</code> 並且 <code>CMD</code> 預設執行這兩個檔案。</p>

<p>但是這兩個檔案現在實際不存在，我會透過 jenkins 的 build scripts 來寫這兩個檔案，其實也就是原本在 build scripts 的內容移到這兩個檔案中了。之所以不把這兩個檔案存在某處再複製過來，就是想保留原本在 Jenkins configure 可以調整 Build Script 的機制，多留一點彈性。</p>

<p>為什麼要這麼麻煩使用 ONBUILD + CMD ，而不是直接 RUN 然後最後直接看 Image 有沒有建置成功就好？除了上述想多留一點彈性的原因外，還有用 Build 這樣 Build 的過程勢必會跑這兩支 script, 而我有可能 Build 完以後不跑這兩支 script, 而是做一些其他的動作例如 <code>/bin/bash</code> 進去 debug 等等，當然可以透過改寫這兩支 script 的內容來使 Build 過程不跑測試，但增添了複雜度。使用這個機制我覺得是最有彈性的。</p>

<h3>Jenkins Build Script</h3>

<p>Jenkins build script 這邊改動的幅度不大，原本的流程大概是：</p>

<ol>
<li><p>改好相關 application.yml, database.yml 等等 local 設定檔並塞進去。</p></li>
<li><p>跑 db:reset 等等重置環境</p></li>
<li><p>跑測試</p></li>
</ol>


<p>基本步驟還是一樣，第一步可以完全不用變，後面就得修改一下，例如：</p>

<p>```</p>

<h1>Start services in docker</h1>

<p>echo &ldquo;
Xvfb :99 -screen 0 1366x768x24 -ac 2>/dev/null >/dev/null &amp;
/etc/init.d/postgresql start &amp;&amp;\
/etc/init.d/redis-server start &amp;&amp;\
/etc/init.d/elasticsearch start
&rdquo; > start_services.sh</p>

<h1>Run tests</h1>

<p>echo &ldquo;
rvm all do bundle exec rake db:migrate &amp;&amp;\
DISPLAY=:99 rvm all do bundle exec rspec spec &mdash;format=documentation
&rdquo; > run_tests.sh</p>

<p>echo &ldquo;FROM project/test&rdquo; > Dockerfile
docker build &mdash;rm -t project/$BUILD_NUMBER .
docker run &mdash;rm project/$BUILD_NUMBER
```</p>

<p>一開始用 echo 寫入兩個檔案，內容大致就是開啟 service 並且開始跑測試，值得注意的是我們在 Jenkins workspace 裡寫了一個新的 Dockerfile, 裡面只有一行內容 <code>FROM project/test</code> 配合之前的 <code>ONBUILD</code> 就可以建置出這個 image. 之所以不直接用 <code>&lt;</code> 的方式把內容丟到 <code>docker build</code> 指令，是因為 <code>ADD</code> 需要 context, 也就是 Jenkins workspace, 所以必須要寫實體的檔案出來。</p>

<p>Image tag 直接取用 Jenkins 的環境變數 <code>$BUILD_NUMBER</code> 因此像第 300 個 build 他的 image 就會叫 <code>project/300</code> 清楚明瞭。</p>

<p>Build 和 Run 都使用 <code>--rm</code> 來確保跑完以後就刪除，節省系統空間。當然如果有保留的需求，例如這個跑完以後自動 trigger 一個專門測 IE 的 selenium test target 的話這邊是可以不用刪除的，看個人需求。</p>

<p>Build 完以後也可以同時跑好幾個 containers，利用一個 image 可以跑很多 containers 的特性，例如把 spec 目錄分成幾區，同時開始跑測試，這樣平行處理可以節省時間。</p>

<p>這邊有一個問題就是 <code>docker run</code> 理論上要回傳 command 的 exit code 不過這部分常常出問題，<a href="https://github.com/dotcloud/docker/issues/6259">時好時壞</a> 所以這邊我決定自己來處理。</p>

<p>想法很簡單，直接把 <code>docker run</code> 的 output 拿來檢查，有偵測到爆炸的話就寫一個檔案，最後來檢查檔案，如果沒過就手動爆炸。等這個 bug 修復穩定之後，就可以不要使用這個 workaround 了。</p>

<p><code>``
docker run --rm project/$BUILD_NUMBER | perl -pe '/Failed examples:/ &amp;&amp;</code>echo &ldquo;fail&rdquo; > docker-tests-failed`&lsquo;
docker rmi project/$BUILD_NUMBER</p>

<p>if [ ! -f docker-tests-failed ]; then
  echo -e &ldquo;No docker-tests-failed file. Apparently tests passed.&rdquo;
else
  echo -e &ldquo;docker-tests-failed file found, so build failed.&rdquo;
  rm docker-tests-failed
  exit 1
fi
```</p>

<p>如果你沒有遇到這個問題，或者你是使用 <a href="https://github.com/sj26/rspec_junit_formatter">rspec_junit_formatter</a> 之類的套件產生 JUnit 檔案的話並加掛 Post-build action 的話，這個動作會讀 JUnit 檔案的內容來改變 Build result 因此也不需要這個 workaround.</p>

<h2>其他整合</h2>

<ul>
<li><p>Jenkins 有一個 plugin <a href="https://wiki.jenkins-ci.org/display/JENKINS/GitHub+pull+request+builder+plugin">Github Pull Request Builder</a> 可以讓 Jenkins 像 travis-ci 那類 service 在 Github 有人發 PR 時自動抓回來 Build。</p></li>
<li><p>Hipchat plugin 可以整合到公司通訊軟體。</p></li>
<li><p><a href="https://github.com/sj26/rspec_junit_formatter">rspec_junit_formatter</a> 可以把 rspec 的結果產生成 JUnit 的 xml 給 Jenkins 讀取。</p></li>
<li><p>Test Coverage 的部分我們則是使用 <a href="https://github.com/colszowka/simplecov">SimpleCov</a> 可以搭配 <a href="https://github.com/fguillen/simplecov-rcov">SimpleCov Rcov Formatter</a> 產生 Jenkins 可讀的報表。</p></li>
</ul>


<p>要使用以上這兩個套件，必須在測試跑完以後使用 <code>docker cp &lt;file&gt; .</code> 指令把報表複製回 workspace 讓 Jenkins 讀取。</p>

<h2>參考連結</h2>

<p>這邊列出一些不錯的連結：</p>

<ul>
<li><a href="http://www.tech-d.net/2014/02/06/docker-quicktip-3-onbuild/">Docker quicktip #3 – ONBUILD</a></li>
<li><a href="http://www.powpark.com/blog/programming/2014/01/29/integrating-docker-with-jenkins-for-ruby-on-rails-app">Integrating Docker with Jenkins for continuous deployment of a Ruby on Rails application</a></li>
<li><a href="http://www.activestate.com/blog/2014/01/using-docker-run-ruby-rspec-ci-jenkins">Using Docker To Run Ruby Rspec CI In Jenkins</a></li>
<li><a href="http://blog.gemnasium.com/post/66356385701/your-dockerfile-for-rails">Your Dockerfile for Rails</a></li>
<li><a href="http://ngauthier.com/2013/10/using-docker-to-parallelize-rails-tests.html">Using Docker to Parallelize Rails Tests</a></li>
<li><a href="https://zapier.com/engineering/continuous-integration-jenkins-docker-github/">How to Set Up TravisCI-like Continuous Integration with Docker and Jenkins</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker Basics]]></title>
    <link href="http://blog.hsatac.net/2014/06/docker-basics/"/>
    <updated>2014-06-29T10:52:00+08:00</updated>
    <id>http://blog.hsatac.net/2014/06/docker-basics</id>
    <content type="html"><![CDATA[<p>隨著 AWS Elastic Beanstalk <a href="http://docs.aws.amazon.com/elasticbeanstalk/latest/dg/create_deploy_docker.html">支援 Docker</a>, Google Computer Engine 也宣布<a href="https://developers.google.com/compute/docs/containers/container_vms">支援 Docker</a>，以及 Google 最近發表的一些 container 工具例如 <a href="https://github.com/google/cadvisor">cAdvisor</a> 這套分析 container 資源和效能的軟體，也同時支援 Google 自己的 <a href="https://github.com/google/lmctfy">lmctfy</a> 和 Docker 來看，Docker 真的是越來越普及了。這個月 Docker 更<a href="http://blog.docker.com/2014/06/its-here-docker-1-0/">釋出了 1.0 版</a> 標誌著 Docker 已經 production-ready 了。</p>

<p>關於 Docker 的概念這邊不多加著墨，可以直接上 <a href="http://www.docker.com/">Docker 官網</a> 閱讀。第一次接觸的朋友可以花十分鐘玩一下 <a href="http://www.docker.com/tryit/">Try Docker</a>。這邊先簡單筆記一些名詞解說和常用的指令。</p>

<!--more-->


<h2>Containers and Images</h2>

<p>使用 Docker 時很常見到 container 和 image 這兩個名詞。</p>

<p>Image 是做好的磁碟檔案，可以透過四種方式取得，一種是 <code>docker pull</code> 拉下遠端檔案、另一種是 <code>docker build</code> 從 <code>Dockerfile</code> 開始建置、第三種是 <code>docker commit</code> 從某個 container commit 成 image, 第四種則是 <code>docker import</code> 匯入。</p>

<p>Container 則是 <code>docker run</code> 某個 image 時產生的，可以透過 <code>docker ps</code> 查看正在運行中的 containers, 一個 image 可以同時運行好幾個 containers. <code>docker ps -a</code> 可以查看所有包含停止運行的 containers. 當 container 停止運行後，磁碟中的檔案會存在該 container 中，但記憶體中的資料都會消失。在 Docker 0.12 版本中使用 cgroup freeze 機制，加入了 <code>docker pause</code> 和 <code>docker unpause</code> 指令，可以 suspend 和 resume 指定的 container.</p>

<p>會注意到每個 image 和 container 都有一個 hash id, 當你每 commit 一次上去時其實就是透過 aufs 疊了一層檔案上去。</p>

<h2>常用指令</h2>

<p>```
docker ps</p>

<h1>列出運行中的 container</h1>

<p>docker ps -a</p>

<h1>列出所有 container</h1>

<p>docker images</p>

<h1>列出 image</h1>

<p>docker rm <container id></p>

<h1>刪除 continer</h1>

<p>docker rmi <image id></p>

<h1>刪除 image</h1>

<p>docker build .</p>

<h1>Build ./Dockerfile 的 image</h1>

<p>docker build &mdash;rm .</p>

<h1>Build 但是刪除 intermediate layer, 也就是不會保留中間步驟產生的 container</h1>

<p>docker build &mdash;no-cache .</p>

<h1>不使用 cache, 會從頭重新 build</h1>

<p>docker build -t kktix/base .</p>

<h1>build 完以後給他一個 tag kktix/base</h1>

<p>docker build &mdash;rm &mdash;no-cache -t base .</p>

<h1>組合技</h1>

<p>docker run base</p>

<h1>跑 base image，會產生一個 container</h1>

<p>docker run base /bin/ping www.google.com</p>

<h1>跑 base image 並指定指令</h1>

<p>docker run -d base /bin/ping www.google.com</p>

<h1>用 daemon 模式跑</h1>

<p>docker run -i -t base /bin/bash</p>

<h1>(i)nterative (t)ty 跑 bash 就等於是進去他的 shell</h1>

<p>docker run &mdash;rm base /bin/ping www.google.com</p>

<h1>跑完以後自動把這個 container 砍掉，注意 &mdash;rm 和 -d 無法同時下</h1>

<p>docker run -v /host/folder:/docker/folder base</p>

<h1>把 Host 的目錄 mount 到 docker container 的目錄</h1>

<p>docker run -d -i -t base /bin/bash</p>

<h1>組合技，這樣可以用 docker attach 回去 shell</h1>

<p>docker attach <container id></p>

<h1>attach 回某個 container</h1>

<h1>如果跑的時候不是給 -d -i -t /bin/bash 的話是不能下指令的</h1>

<h1>ctrl + c 會跳出。</h1>

<h1>但如果是 -d -i -t /bin/bash ctrl + c 會 stop 整個 container.</h1>

<h1>在此情況下不想停止 container 只想跳出請用 ctrl + p, ctrl + q</h1>

<p>```</p>

<h2>Dockerfile</h2>

<p>Dockerfile 是用來建置 Docker image 的檔案，簡介可以直接參考<a href="http://docs.docker.com/reference/builder/">官方文件</a>，這邊筆記一些容易搞錯的部分。</p>

<h3>ENTRYPOINT, CMD and RUN</h3>

<ul>
<li><p><code>RUN</code> 是最基本的，就單純是在 build 的時候跑某個指令。</p></li>
<li><p><code>CMD</code> 則是 <code>docker run &lt;image&gt; &lt;command&gt;</code> 時，如果沒有指定 command 時會跑的指令。</p></li>
<li><p><code>ENTRYPOINT</code> 則是設定 <code>docker run &lt;image&gt; &lt;command&gt;</code> 時，用來接 command 的指令。預設的 <code>ENTRYPOINT</code> 是 <code>/bin/sh -c</code> ，例如我們把 <code>ENTRYPOINT</code> 改成 <code>/usr/bin/redis-cli</code> 這樣當我們跑 <code>docker run redis monitor</code> 時，他實際執行的指令就會是 <code>/usr/bin/redis-cli monitor</code>。</p></li>
</ul>


<h3>ADD vs COPY</h3>

<p><code>ADD</code> 會把你指定的檔案或目錄複製到 docker image 中，需要注意的是他不能用 <code>../</code> 指定到當前目錄(context) 之外，並且如果你是用 <code>docker build - &lt; somefile</code> 這樣的方式也沒辦法使用，因為沒有 context。</p>

<p><code>ADD</code> 和 <code>COPY</code> 基本上是一樣的，唯一的差別在於當使用 <code>ADD</code> 時，如果檔案是認得的壓縮檔(gzip, bzip2 or xz) 他會自動幫你解壓縮，而 COPY 則不會。</p>

<h3>ONBUILD</h3>

<p><code>ONBUILD</code> 是一個很好用的功能，他不會發生在你這個 Dockerfile 的建置過程中，而是「用此 Dockerfile 建置出來的 IMAGE 來建置」的過程才會觸發。</p>

<p>舉例你用現在的 Dockerfile 建立了一個 image 叫做 base, 當有另一個 Dockerfile 使用 <code>FROM base</code> 來建置 image 時才會跑 <code>ONBUILD</code> 這行。這是一個有點 tricky 但又很實用的功能。</p>

<h2>小結</h2>

<p>Docker 真的是把 linux container 的操作難度降低非常多，也加上了很多實用的功能以及安全性的限制，他可以運用的範圍非常廣，接下來預計寫幾篇我們實際運用 docker 的例子和筆記。</p>

<h2>補充</h2>

<p>如果你是在 Mac 上使用 docker, 其實他底下是透過 boot2docker 連到一個 vm 裡面去跑 docker, 但是 Mac 常常蓋上電腦就走，這時 vm suspend 後開機 resume 時間都會跑掉，很容易造成靈異現象。這時要進去 boot2docker 的 vm 裡面調整時間。</p>

<p><code>
$ boot2docker ssh # 密碼 tcuser
$ sudo /usr/local/bin/ntpclient -s -h pool.ntp.org
</code></p>

<p>可以考慮把這段寫成 crontab 省功夫。</p>
]]></content>
  </entry>
  
</feed>
