<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ror | hSATAC]]></title>
  <link href="http://blog.hsatac.net/categories/ror/atom.xml" rel="self"/>
  <link href="http://blog.hsatac.net/"/>
  <updated>2014-06-30T01:55:50+08:00</updated>
  <id>http://blog.hsatac.net/</id>
  <author>
    <name><![CDATA[Ash Wu]]></name>
    <email><![CDATA[hsatac@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[整合 Jenkins 和 Docker]]></title>
    <link href="http://blog.hsatac.net/2014/06/working-with-docker-and-jenkins/"/>
    <updated>2014-06-29T22:51:00+08:00</updated>
    <id>http://blog.hsatac.net/2014/06/working-with-docker-and-jenkins</id>
    <content type="html"><![CDATA[<p>這篇將會記述一些我自己整合 Jenkins CI 和 Docker 的思路、想法、要點以及備忘。不會有 step by step 的教學，若有此類需求請參考最後附錄。</p>

<h2>Why Docker?</h2>

<p>Jenkins 跑的好好的，為什麼要摻 Docker 呢？原本我們 Rails Rspec 跑的其實也不錯，但受限於 database 以及 elasticsearch, redis 等 services，無法同時跑多個 worker, 再加上未來若有平行化測試以及多個專案 / 不同 db 版本等等的需求，引入 docker 可以完美解決這些問題。</p>

<h2>Concept</h2>

<p>使用 Docker 的好處就是原本的 shell script 幾乎都不用改即可繼續使用，引入的門檻降到極低。</p>

<p>基本概念是建立一個可以跑 Rails app 起來的環境，然後把整個 CI 的 workspace 丟進去跑測試，其他的步驟都一模一樣。</p>

<p>在建立環境這邊基本上有兩個選擇，一種是全部包成一個 image, 就用這個 container 來跑測試。另一種是每個需要的 service 都是一個各自的 container, 彼此之間透過 <a href="https://docs.docker.com/userguide/dockerlinks/">Docker Container Linking</a> 來通訊，例如 postgresql 自己一個、elasticsearch 自己一個、rails 自己一個這樣。</p>

<p>不過由於跑測試都是用過即丟，這次我直接採用最簡單的包一大包的策略來進行，減少複雜度。</p>

<!--more-->


<h3>Base Image</h3>

<p>我的設計是先建立一個 base image 例如給他 tag 叫 <code>project/base</code> 裡面先預裝好了所有環境包括 pg, elasticsearch, redis, rvm, ruby 等等。</p>

<p>舉例來說可能長這樣：</p>

<p>```
FROM ubuntu:12.04
MAINTAINER hSATAC</p>

<h1>We use bash</h1>

<p>RUN rm /bin/sh &amp;&amp; ln -s /bin/bash /bin/sh</p>

<h1>We don&rsquo;t like apt-get warnings.</h1>

<p>ENV DEBIAN_FRONTEND noninteractive</p>

<h1>Add the PostgreSQL PGP key to verify their Debian packages.</h1>

<h1>It should be the same key as <a href="https://www.postgresql.org/media/keys/ACCC4CF8.asc">https://www.postgresql.org/media/keys/ACCC4CF8.asc</a></h1>

<p>RUN apt-key adv &mdash;keyserver keyserver.ubuntu.com &mdash;recv-keys B97B0AFCAA1A47F044F244A07FCC7D46ACCC4CF8</p>

<h1>Add PostgreSQL&rsquo;s repository. It contains the most recent stable release</h1>

<h1>of PostgreSQL, <code>9.3</code>.</h1>

<p>RUN echo &ldquo;deb <a href="http://apt.postgresql.org/pub/repos/apt/">http://apt.postgresql.org/pub/repos/apt/</a> precise-pgdg main&rdquo; > /etc/apt/sources.list.d/pgdg.list</p>

<h1>Update the Ubuntu and PostgreSQL repository indexes</h1>

<p>RUN apt-get update</p>

<h1>=== Locale ===</h1>

<p>RUN locale-gen  en_US.UTF-8
ENV LANG en_US.UTF-8
ENV LANGUAGE en_US.UTF-8
ENV LC_ALL en_US.UTF-8</p>

<h1>=== Requirements ===</h1>

<p>RUN apt-get -y -q install nodejs libpq-dev wget git curl imagemagick vim postfix</p>

<p>RUN cd /tmp &amp;&amp;\</p>

<pre><code>wget http://downloads.sourceforge.net/project/wkhtmltopdf/0.12.0/wkhtmltox-linux-amd64_0.12.0-03c001d.tar.xz &amp;&amp;\
tar Jxvf wkhtmltox-linux-amd64_0.12.0-03c001d.tar.xz &amp;&amp;\
cd wkhtmltox &amp;&amp;\
install bin/wkhtmltoimage /usr/bin/wkhtmltoimage
</code></pre>

<h1>=== Redis ===</h1>

<p>RUN apt-get -y -q install redis-server</p>

<h1>=== Elasticsearch ===</h1>

<p>RUN apt-get install openjdk-7-jre-headless -y -q
RUN wget <a href="https://download.elasticsearch.org/elasticsearch/elasticsearch/elasticsearch-1.1.0.deb">https://download.elasticsearch.org/elasticsearch/elasticsearch/elasticsearch-1.1.0.deb</a>
RUN dpkg -i elasticsearch-1.1.0.deb</p>

<h1>=== RVM ===</h1>

<p>RUN curl -L <a href="https://get.rvm.io">https://get.rvm.io</a> | bash -s stable
ENV PATH /usr/local/rvm/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
RUN /bin/bash -l -c rvm requirements
RUN source /usr/local/rvm/scripts/rvm &amp;&amp; rvm install ruby-2.1.2
RUN rvm all do gem install bundler</p>

<h1>=== Postgresql ===</h1>

<p>RUN apt-get -y -q install python-software-properties software-properties-common
RUN apt-get -y -q install postgresql-9.3 postgresql-client-9.3 postgresql-contrib-9.3</p>

<h1>Update template1 to enable UTF-8 and hstore</h1>

<p>USER postgres
RUN    /etc/init.d/postgresql start &amp;&amp;\</p>

<pre><code>psql -c "update pg_database set datistemplate=false where datname='template1';" &amp;&amp;\
psql -c 'drop database Template1;' &amp;&amp;\
psql -c "create database template1 with owner=postgres encoding='UTF-8' lc_collate='en_US.utf8' lc_ctype='en_US.utf8' template template0;" &amp;&amp;\
psql -c 'CREATE EXTENSION hstore;' -d template1
</code></pre>

<h1>Create a PostgreSQL role and db</h1>

<p>RUN    /etc/init.d/postgresql start &amp;&amp;\</p>

<pre><code>psql --command "CREATE ROLE jenkins LOGIN PASSWORD 'jenkins' SUPERUSER INHERIT CREATEDB NOCREATEROLE NOREPLICATION;" &amp;&amp;\
createdb -O jenkins jenkins_test &amp;&amp;\
createdb -O jenkins jenkins_production
</code></pre>

<h1>Adjust PostgreSQL configuration</h1>

<p>RUN echo &ldquo;local all  all  md5&rdquo; > /etc/postgresql/9.3/main/pg_hba.conf</p>

<h1>And add <code>listen_addresses</code> to <code>/etc/postgresql/9.3/main/postgresql.conf</code></h1>

<p>RUN echo &ldquo;listen_addresses=&lsquo;*&rsquo;&rdquo; >> /etc/postgresql/9.3/main/postgresql.conf
```</p>

<h3>Test Image</h3>

<p>接著用 <code>project/base</code> build 一個 <code>project/test</code>，這個 image 會安裝一些「只有測試會用到」的套件，順便把 Gemfile 複製進去安裝一下 Gem, 這樣到時在跑測試的時候就可以省略 <code>bundle install</code> 的時間了。因為我的 base image 還有打算拿來做其他用途，所以這邊是這樣設計。</p>

<p>每天凌晨三點左右用 crontab 重新 Build 一次這個 <code>project/test</code> 的 image 以更新 gems. 當然這邊牽涉到一些如何同步你專案中的 Gemfile 不過這都是簡單的 script 可以解決的問題，這邊不贅述。</p>

<p>```
FROM project/base</p>

<h1>Switch back to root</h1>

<p>USER root</p>

<h1>Set ENV</h1>

<p>ENV RAILS_ENV test</p>

<h1>Preinstall gem</h1>

<p>ADD gem /opt/project_gem # 這個 gem 目錄裡面有 Gemfile 和 Gemfile.lock
WORKDIR /opt/project_gem
RUN rvm all do bundle install</p>

<h1>Install Firefox &amp; Xvfb</h1>

<p>RUN apt-get -y install firefox xvfb # 跑 selenium test 用的</p>

<h1>Onbuild witch back to root</h1>

<p>ONBUILD USER root</p>

<h1>Mound Rails directory</h1>

<p>ONBUILD ADD . /opt/project
ONBUILD WORKDIR /opt/project</p>

<h1>Bundle install</h1>

<p>ONBUILD RUN rvm all do bundle install</p>

<h1>Go</h1>

<p>ONBUILD ADD start_services.sh /opt/project/start_services.sh
ONBUILD RUN chmod +x /opt/project/start_services.sh
ONBUILD ADD run_tests.sh /opt/project/run_tests.sh
ONBUILD RUN chmod +x /opt/project/run_tests.sh
ONBUILD CMD /opt/project/start_services.sh &amp;&amp; /opt/project/run_tests.sh
```</p>

<p>注意這邊最後一段用到了上一篇文章 <a href="/2014/06/docker-basics/">Docker Basics</a> 中所講到的 ONBUILD, 使用這個功能我們就可以很輕鬆的 build 出真正用來測試的 Image.</p>

<p>這幾行實際做的動作是複製兩個 scripts 分別名叫 <code>start_services.sh</code> 和 <code>run_tests.sh</code> 並且 <code>CMD</code> 預設執行這兩個檔案。</p>

<p>但是這兩個檔案現在實際不存在，我會透過 jenkins 的 build scripts 來寫這兩個檔案，其實也就是原本在 build scripts 的內容移到這兩個檔案中了。之所以不把這兩個檔案存在某處再複製過來，就是想保留原本在 Jenkins configure 可以調整 Build Script 的機制，多留一點彈性。</p>

<p>為什麼要這麼麻煩使用 ONBUILD + CMD ，而不是直接 RUN 然後最後直接看 Image 有沒有建置成功就好？除了上述想多留一點彈性的原因外，還有用 Build 這樣 Build 的過程勢必會跑這兩支 script, 而我有可能 Build 完以後不跑這兩支 script, 而是做一些其他的動作例如 <code>/bin/bash</code> 進去 debug 等等，當然可以透過改寫這兩支 script 的內容來使 Build 過程不跑測試，但增添了複雜度。使用這個機制我覺得是最有彈性的。</p>

<h3>Jenkins Build Script</h3>

<p>Jenkins build script 這邊改動的幅度不大，原本的流程大概是：</p>

<ol>
<li><p>改好相關 application.yml, database.yml 等等 local 設定檔並塞進去。</p></li>
<li><p>跑 db:reset 等等重置環境</p></li>
<li><p>跑測試</p></li>
</ol>


<p>基本步驟還是一樣，第一步可以完全不用變，後面就得修改一下，例如：</p>

<p>```</p>

<h1>Start services in docker</h1>

<p>echo &ldquo;
Xvfb :99 -screen 0 1366x768x24 -ac 2>/dev/null >/dev/null &amp;
/etc/init.d/postgresql start &amp;&amp;\
/etc/init.d/redis-server start &amp;&amp;\
/etc/init.d/elasticsearch start
&rdquo; > start_services.sh</p>

<h1>Run tests</h1>

<p>echo &ldquo;
rvm all do bundle exec rake db:migrate &amp;&amp;\
DISPLAY=:99 rvm all do bundle exec rspec spec &mdash;format=documentation
&rdquo; > run_tests.sh</p>

<p>echo &ldquo;FROM project/test&rdquo; > Dockerfile
docker build &mdash;rm -t project/$BUILD_NUMBER .
docker run &mdash;rm project/$BUILD_NUMBER
```</p>

<p>一開始用 echo 寫入兩個檔案，內容大致就是開啟 service 並且開始跑測試，值得注意的是我們在 Jenkins workspace 裡寫了一個新的 Dockerfile, 裡面只有一行內容 <code>FROM project/test</code> 配合之前的 <code>ONBUILD</code> 就可以建置出這個 image. 之所以不直接用 <code>&lt;</code> 的方式把內容丟到 <code>docker build</code> 指令，是因為 <code>ADD</code> 需要 context, 也就是 Jenkins workspace, 所以必須要寫實體的檔案出來。</p>

<p>Image tag 直接取用 Jenkins 的環境變數 <code>$BUILD_NUMBER</code> 因此像第 300 個 build 他的 image 就會叫 <code>project/300</code> 清楚明瞭。</p>

<p>Build 和 Run 都使用 <code>--rm</code> 來確保跑完以後就刪除，節省系統空間。當然如果有保留的需求，例如這個跑完以後自動 trigger 一個專門測 IE 的 selenium test target 的話這邊是可以不用刪除的，看個人需求。</p>

<p>Build 完以後也可以同時跑好幾個 containers，利用一個 image 可以跑很多 containers 的特性，例如把 spec 目錄分成幾區，同時開始跑測試，這樣平行處理可以節省時間。</p>

<p>這邊有一個問題就是 <code>docker run</code> 理論上要回傳 command 的 exit code 不過這部分常常出問題，<a href="https://github.com/dotcloud/docker/issues/6259">時好時壞</a> 所以這邊我決定自己來處理。</p>

<p>想法很簡單，直接把 <code>docker run</code> 的 output 拿來檢查，有偵測到爆炸的話就寫一個檔案，最後來檢查檔案，如果沒過就手動爆炸。等這個 bug 修復穩定之後，就可以不要使用這個 workaround 了。</p>

<p><code>``
docker run --rm project/$BUILD_NUMBER | perl -pe '/Failed examples:/ &amp;&amp;</code>echo &ldquo;fail&rdquo; > docker-tests-failed`&lsquo;
docker rmi project/$BUILD_NUMBER</p>

<p>if [ ! -f docker-tests-failed ]; then
  echo -e &ldquo;No docker-tests-failed file. Apparently tests passed.&rdquo;
else
  echo -e &ldquo;docker-tests-failed file found, so build failed.&rdquo;
  rm docker-tests-failed
  exit 1
fi
```</p>

<h2>其他整合</h2>

<p>Jenkins 有一個 plugin <a href="https://wiki.jenkins-ci.org/display/JENKINS/GitHub+pull+request+builder+plugin">Github Pull Request Builder</a> 可以讓 Jenkins 像 travis-ci 那類 service 在 Github 有人發 PR 時自動抓回來 Build。</p>

<p>另外也有 hipchat plugin 可以整合到公司通訊軟體，這部分和主題相關薄弱就不多談了。</p>

<h2>參考連結</h2>

<p>這邊列出一些不錯的連結：</p>

<ul>
<li><a href="http://www.tech-d.net/2014/02/06/docker-quicktip-3-onbuild/">Docker quicktip #3 – ONBUILD</a></li>
<li><a href="http://www.powpark.com/blog/programming/2014/01/29/integrating-docker-with-jenkins-for-ruby-on-rails-app">Integrating Docker with Jenkins for continuous deployment of a Ruby on Rails application</a></li>
<li><a href="http://www.activestate.com/blog/2014/01/using-docker-run-ruby-rspec-ci-jenkins">Using Docker To Run Ruby Rspec CI In Jenkins</a></li>
<li><a href="http://blog.gemnasium.com/post/66356385701/your-dockerfile-for-rails">Your Dockerfile for Rails</a></li>
<li><a href="http://ngauthier.com/2013/10/using-docker-to-parallelize-rails-tests.html">Using Docker to Parallelize Rails Tests</a></li>
<li><a href="https://zapier.com/engineering/continuous-integration-jenkins-docker-github/">How to Set Up TravisCI-like Continuous Integration with Docker and Jenkins</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails i18n Relative Key in Controller Before Action]]></title>
    <link href="http://blog.hsatac.net/2014/04/rails-i18n-relative-key-in-controller-before-action/"/>
    <updated>2014-04-12T04:42:00+08:00</updated>
    <id>http://blog.hsatac.net/2014/04/rails-i18n-relative-key-in-controller-before-action</id>
    <content type="html"><![CDATA[<p>在 Rails i18n 裡面可以用 relative path 像 <code>t('.key')</code> 這樣的 shortcut，不過這個 shortcut 吃得是 <code>"#{ controller_path.tr('/', '.') }.#{ action_name }#{ key }"</code>。</p>

<p>今天碰到 controller 的 before action 裡面用 relative path 結果 locale yml 編到 before action 的 key，但真正會去 lookup 的是 <code>action_name</code> 而不是 before action 的 method name 所以就爆 missing 了。</p>

<p>萬一這個 before_action 之後多加幾個其他的 action 的話很容易就沒改到 locale yml 而爆錯誤，為了保險起見決定把他們都改成 absolute key path. 不過 controller 檔案非常多，所以要寫一隻程式把所有 before action 裡面有用到 relative path 的 t 撈出來。</p>

<p>一開始的想法是用 regex 速解，不過因為 controller 裡面的 t 還滿多的，然後我又很難判斷 before action method 的 scope，於是念頭一轉就直接改用 <a href="https://github.com/whitequark/parser">Ruby Parser</a> 來做。</p>

<p>直接把 controller 檔案都讀進來，拿 AST 來抓 before actions，再去檢查這些 before action 是否有 call 到 relative keypath 的 t。用起來還滿方便的，效率也不差，一下子就寫完了。</p>

<p>程式碼放在 <a href="https://github.com/hSATAC/parse-relative-key">Github</a>，不過這麼特定目的東西應該是無法重用，放著以後有需要的時候回來看一下。</p>

<p>最後就是&hellip;i18n 沒事還是不要用 relative key 比較好&hellip;散在 controller, helper, service 裡面到時要搬移 code 或者作 refactor 的時候就麻煩了。動態語言重構不像靜態語言這麼便利啊&hellip;。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xray-rails 與 tmux, vim 整合]]></title>
    <link href="http://blog.hsatac.net/2013/07/xray-rails-tmux-vim-integration/"/>
    <updated>2013-07-09T22:00:00+08:00</updated>
    <id>http://blog.hsatac.net/2013/07/xray-rails-tmux-vim-integration</id>
    <content type="html"><![CDATA[<p>剛好又開新專案了，來介紹一下 <a href="https://github.com/brentd/xray-rails">Xray-rails</a> 與 tmux, vim 的整合。</p>

<p><a href="https://github.com/brentd/xray-rails">Xray-rails</a> 是一層 rack middleware，會 inject 你的 view 和 javascript 檔案，只要在開發模式按快速鍵 <code>⌘ + ⇧ + x</code> 就會開啟一層 overlay，讓你很清楚的看出現在的畫面由哪些 view, partial, controller 生成，更方便的是只要一點畫面，即可在編輯器中開啟該檔案，大大降低 trace 程式碼的時間。</p>

<p><img src="https://dl.dropboxusercontent.com/u/156655/xray-screenshot.png" alt="Xray-rails" /></p>

<!--more-->


<p><a href="https://github.com/brentd/xray-rails">Xray-rails</a> 預設的編輯器是 <a href="http://www.sublimetext.com/2">Sublime Text 2</a> (<code>/usr/local/bin/subl</code>)。可以透過 overlay 右下角的設定圖示、或者自己新增 <code>~/.xrayconfig</code> 檔案來設定你使用的編輯器。</p>

<p>我平常使用 <a href="https://github.com/aziz/tmuxinator">Tmuxinator</a> 來管理我的專案和 tmux, 每個專案有自己的 tmux session，讓我可以快速在不同專案的開發環境之間切換。</p>

<p>我的 <code>~/.xrayconfig</code> 也改成透過 tmux 傳送指令給我的 vim，範例設定檔如下：</p>

<p><code>
:editor: "/usr/local/bin/tmux send -t openapply:editor ESCAPE :tabe $file ENTER"
</code></p>

<p><code>openapply</code> 是我的專案 tmux session 名稱，而 <code>editor</code> 是該 session 的 window 名稱，專門用來開啟 vim 編輯檔案。</p>

<p>但問題來了，我每一個專案都有自己獨立的 tmux session，這樣每次切換專案的時候我都要修改 <code>~/.xrayconfig</code> 實在很不方便，所以希望能在每一個專案底下放自己的 <code>.xrayconfig</code>。</p>

<p><p class='info info' data-title='Update 2013/08/14'>這個 Pull request 已被 upstream 收下，可以直接使用官方 git repo。</p></p>

<p>這個功能已經<a href="https://github.com/brentd/xray-rails/issues/21">提案給原作者同意</a>，也送了 <a href="https://github.com/brentd/xray-rails/pull/23">pull request</a>，不過還沒被 merge 回主幹，如果現在有需要這個功能的朋友可以暫時先使用我修改的 fork。</p>

<p>```
  gem &lsquo;xray-rails&rsquo;, :git => &lsquo;<a href="https://github.com/hSATAC/xray-rails.git">https://github.com/hSATAC/xray-rails.git</a>&rsquo;,</p>

<pre><code>                :branch =&gt; 'feature/project_specific_config'
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
</feed>
