<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ci | hSATAC]]></title>
  <link href="http://blog.hsatac.net/categories/ci/atom.xml" rel="self"/>
  <link href="http://blog.hsatac.net/"/>
  <updated>2014-10-18T18:50:06+08:00</updated>
  <id>http://blog.hsatac.net/</id>
  <author>
    <name><![CDATA[Ash Wu]]></name>
    <email><![CDATA[hsatac@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[整合 Jenkins 和 Docker]]></title>
    <link href="http://blog.hsatac.net/2014/06/working-with-docker-and-jenkins/"/>
    <updated>2014-06-29T22:51:00+08:00</updated>
    <id>http://blog.hsatac.net/2014/06/working-with-docker-and-jenkins</id>
    <content type="html"><![CDATA[<p>這篇將會記述一些我自己整合 Jenkins CI 和 Docker 的思路、想法、要點以及備忘。不會有 step by step 的教學，若有此類需求請參考最後附錄。</p>

<h2>Why Docker?</h2>

<p>Jenkins 跑的好好的，為什麼要摻 Docker 呢？原本我們 Rails Rspec 跑的其實也不錯，但受限於 database 以及 elasticsearch, redis 等 services，無法同時跑多個 worker, 再加上未來若有平行化測試以及多個專案 / 不同 db 版本等等的需求，引入 docker 可以完美解決這些問題。</p>

<h2>Concept</h2>

<p>使用 Docker 的好處就是原本的 shell script 幾乎都不用改即可繼續使用，引入的門檻降到極低。</p>

<p>基本概念是建立一個可以跑 Rails app 起來的環境，然後把整個 CI 的 workspace 丟進去跑測試，其他的步驟都一模一樣。</p>

<p>在建立環境這邊基本上有兩個選擇，一種是全部包成一個 image, 就用這個 container 來跑測試。另一種是每個需要的 service 都是一個各自的 container, 彼此之間透過 <a href="https://docs.docker.com/userguide/dockerlinks/">Docker Container Linking</a> 來通訊，例如 postgresql 自己一個、elasticsearch 自己一個、rails 自己一個這樣。</p>

<p>不過由於跑測試都是用過即丟，這次我直接採用最簡單的包一大包的策略來進行，減少複雜度。</p>

<!--more-->


<p>我會選擇自己 Build docker 來跑測試主要是還想運用在其他地方，包括 trigger 不同的瀏覽器跑 feature tests 而不需重新 Build docker image 等等，如果沒有特殊需求的話也可以參考看看 Jenkins 的 <a href="https://wiki.jenkins-ci.org/display/JENKINS/Docker+Plugin">Docker Plugin</a> 基本概念是直接把 Jenkins slave 用 docker 跑起來。可以評估看看自己是否合用。</p>

<h3>Base Image</h3>

<p>我的設計是先建立一個 base image 例如給他 tag 叫 <code>project/base</code> 裡面先預裝好了所有環境包括 pg, elasticsearch, redis, rvm, ruby 等等。</p>

<p>舉例來說可能長這樣：</p>

<p>```
FROM ubuntu:12.04
MAINTAINER hSATAC</p>

<h1>We use bash</h1>

<p>RUN rm /bin/sh &amp;&amp; ln -s /bin/bash /bin/sh</p>

<h1>We don&rsquo;t like apt-get warnings.</h1>

<p>ENV DEBIAN_FRONTEND noninteractive</p>

<h1>Add the PostgreSQL PGP key to verify their Debian packages.</h1>

<h1>It should be the same key as <a href="https://www.postgresql.org/media/keys/ACCC4CF8.asc">https://www.postgresql.org/media/keys/ACCC4CF8.asc</a></h1>

<p>RUN apt-key adv &mdash;keyserver keyserver.ubuntu.com &mdash;recv-keys B97B0AFCAA1A47F044F244A07FCC7D46ACCC4CF8</p>

<h1>Add PostgreSQL&rsquo;s repository. It contains the most recent stable release</h1>

<h1>of PostgreSQL, <code>9.3</code>.</h1>

<p>RUN echo &ldquo;deb <a href="http://apt.postgresql.org/pub/repos/apt/">http://apt.postgresql.org/pub/repos/apt/</a> precise-pgdg main&rdquo; > /etc/apt/sources.list.d/pgdg.list</p>

<h1>Update the Ubuntu and PostgreSQL repository indexes</h1>

<p>RUN apt-get update</p>

<h1>=== Locale ===</h1>

<p>RUN locale-gen  en_US.UTF-8
ENV LANG en_US.UTF-8
ENV LANGUAGE en_US.UTF-8
ENV LC_ALL en_US.UTF-8</p>

<h1>=== Requirements ===</h1>

<p>RUN apt-get -y -q install nodejs libpq-dev wget git curl imagemagick vim postfix</p>

<p>RUN cd /tmp &amp;&amp;\</p>

<pre><code>wget http://downloads.sourceforge.net/project/wkhtmltopdf/0.12.0/wkhtmltox-linux-amd64_0.12.0-03c001d.tar.xz &amp;&amp;\
tar Jxvf wkhtmltox-linux-amd64_0.12.0-03c001d.tar.xz &amp;&amp;\
cd wkhtmltox &amp;&amp;\
install bin/wkhtmltoimage /usr/bin/wkhtmltoimage
</code></pre>

<h1>=== Redis ===</h1>

<p>RUN apt-get -y -q install redis-server</p>

<h1>=== Elasticsearch ===</h1>

<p>RUN apt-get install openjdk-7-jre-headless -y -q
RUN wget <a href="https://download.elasticsearch.org/elasticsearch/elasticsearch/elasticsearch-1.1.0.deb">https://download.elasticsearch.org/elasticsearch/elasticsearch/elasticsearch-1.1.0.deb</a>
RUN dpkg -i elasticsearch-1.1.0.deb</p>

<h1>=== RVM ===</h1>

<p>RUN curl -L <a href="https://get.rvm.io">https://get.rvm.io</a> | bash -s stable
ENV PATH /usr/local/rvm/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
RUN /bin/bash -l -c rvm requirements
RUN source /usr/local/rvm/scripts/rvm &amp;&amp; rvm install ruby-2.1.2
RUN rvm all do gem install bundler</p>

<h1>=== Postgresql ===</h1>

<p>RUN apt-get -y -q install python-software-properties software-properties-common
RUN apt-get -y -q install postgresql-9.3 postgresql-client-9.3 postgresql-contrib-9.3</p>

<h1>Update template1 to enable UTF-8 and hstore</h1>

<p>USER postgres
RUN    /etc/init.d/postgresql start &amp;&amp;\</p>

<pre><code>psql -c "update pg_database set datistemplate=false where datname='template1';" &amp;&amp;\
psql -c 'drop database Template1;' &amp;&amp;\
psql -c "create database template1 with owner=postgres encoding='UTF-8' lc_collate='en_US.utf8' lc_ctype='en_US.utf8' template template0;" &amp;&amp;\
psql -c 'CREATE EXTENSION hstore;' -d template1
</code></pre>

<h1>Create a PostgreSQL role and db</h1>

<p>RUN    /etc/init.d/postgresql start &amp;&amp;\</p>

<pre><code>psql --command "CREATE ROLE jenkins LOGIN PASSWORD 'jenkins' SUPERUSER INHERIT CREATEDB NOCREATEROLE NOREPLICATION;" &amp;&amp;\
createdb -O jenkins jenkins_test &amp;&amp;\
createdb -O jenkins jenkins_production
</code></pre>

<h1>Adjust PostgreSQL configuration</h1>

<p>RUN echo &ldquo;local all  all  md5&rdquo; > /etc/postgresql/9.3/main/pg_hba.conf</p>

<h1>And add <code>listen_addresses</code> to <code>/etc/postgresql/9.3/main/postgresql.conf</code></h1>

<p>RUN echo &ldquo;listen_addresses=&lsquo;*&rsquo;&rdquo; >> /etc/postgresql/9.3/main/postgresql.conf
```</p>

<h3>Test Image</h3>

<p>接著用 <code>project/base</code> build 一個 <code>project/test</code>，這個 image 會安裝一些「只有測試會用到」的套件，順便把 Gemfile 複製進去安裝一下 Gem, 這樣到時在跑測試的時候就可以省略 <code>bundle install</code> 的時間了。因為我的 base image 還有打算拿來做其他用途，所以這邊是這樣設計。</p>

<p>每天凌晨三點左右用 crontab 重新 Build 一次這個 <code>project/test</code> 的 image 以更新 gems. 當然這邊牽涉到一些如何同步你專案中的 Gemfile 不過這都是簡單的 script 可以解決的問題，這邊不贅述。</p>

<p>```
FROM project/base</p>

<h1>Switch back to root</h1>

<p>USER root</p>

<h1>Set ENV</h1>

<p>ENV RAILS_ENV test</p>

<h1>Preinstall gem</h1>

<p>ADD gem /opt/project_gem # 這個 gem 目錄裡面有 Gemfile 和 Gemfile.lock
WORKDIR /opt/project_gem
RUN rvm all do bundle install</p>

<h1>Install Firefox &amp; Xvfb</h1>

<p>RUN apt-get -y install firefox xvfb # 跑 selenium test 用的</p>

<h1>Onbuild witch back to root</h1>

<p>ONBUILD USER root</p>

<h1>Mound Rails directory</h1>

<p>ONBUILD ADD . /opt/project
ONBUILD WORKDIR /opt/project</p>

<h1>Bundle install</h1>

<p>ONBUILD RUN rvm all do bundle install</p>

<h1>Go</h1>

<p>ONBUILD ADD start_services.sh /opt/project/start_services.sh
ONBUILD RUN chmod +x /opt/project/start_services.sh
ONBUILD ADD run_tests.sh /opt/project/run_tests.sh
ONBUILD RUN chmod +x /opt/project/run_tests.sh
ONBUILD CMD /opt/project/start_services.sh &amp;&amp; /opt/project/run_tests.sh
```</p>

<p>注意這邊最後一段用到了上一篇文章 <a href="/2014/06/docker-basics/">Docker Basics</a> 中所講到的 ONBUILD, 使用這個功能我們就可以很輕鬆的 build 出真正用來測試的 Image.</p>

<p>這幾行實際做的動作是複製兩個 scripts 分別名叫 <code>start_services.sh</code> 和 <code>run_tests.sh</code> 並且 <code>CMD</code> 預設執行這兩個檔案。</p>

<p>但是這兩個檔案現在實際不存在，我會透過 jenkins 的 build scripts 來寫這兩個檔案，其實也就是原本在 build scripts 的內容移到這兩個檔案中了。之所以不把這兩個檔案存在某處再複製過來，就是想保留原本在 Jenkins configure 可以調整 Build Script 的機制，多留一點彈性。</p>

<p>為什麼要這麼麻煩使用 ONBUILD + CMD ，而不是直接 RUN 然後最後直接看 Image 有沒有建置成功就好？除了上述想多留一點彈性的原因外，還有用 Build 這樣 Build 的過程勢必會跑這兩支 script, 而我有可能 Build 完以後不跑這兩支 script, 而是做一些其他的動作例如 <code>/bin/bash</code> 進去 debug 等等，當然可以透過改寫這兩支 script 的內容來使 Build 過程不跑測試，但增添了複雜度。使用這個機制我覺得是最有彈性的。</p>

<h3>Jenkins Build Script</h3>

<p>Jenkins build script 這邊改動的幅度不大，原本的流程大概是：</p>

<ol>
<li><p>改好相關 application.yml, database.yml 等等 local 設定檔並塞進去。</p></li>
<li><p>跑 db:reset 等等重置環境</p></li>
<li><p>跑測試</p></li>
</ol>


<p>基本步驟還是一樣，第一步可以完全不用變，後面就得修改一下，例如：</p>

<p>```</p>

<h1>Start services in docker</h1>

<p>echo &ldquo;
Xvfb :99 -screen 0 1366x768x24 -ac 2>/dev/null >/dev/null &amp;
/etc/init.d/postgresql start &amp;&amp;\
/etc/init.d/redis-server start &amp;&amp;\
/etc/init.d/elasticsearch start
&rdquo; > start_services.sh</p>

<h1>Run tests</h1>

<p>echo &ldquo;
rvm all do bundle exec rake db:migrate &amp;&amp;\
DISPLAY=:99 rvm all do bundle exec rspec spec &mdash;format=documentation
&rdquo; > run_tests.sh</p>

<p>echo &ldquo;FROM project/test&rdquo; > Dockerfile
docker build &mdash;rm -t project/$BUILD_NUMBER .
docker run &mdash;rm project/$BUILD_NUMBER
```</p>

<p>一開始用 echo 寫入兩個檔案，內容大致就是開啟 service 並且開始跑測試，值得注意的是我們在 Jenkins workspace 裡寫了一個新的 Dockerfile, 裡面只有一行內容 <code>FROM project/test</code> 配合之前的 <code>ONBUILD</code> 就可以建置出這個 image. 之所以不直接用 <code>&lt;</code> 的方式把內容丟到 <code>docker build</code> 指令，是因為 <code>ADD</code> 需要 context, 也就是 Jenkins workspace, 所以必須要寫實體的檔案出來。</p>

<p>Image tag 直接取用 Jenkins 的環境變數 <code>$BUILD_NUMBER</code> 因此像第 300 個 build 他的 image 就會叫 <code>project/300</code> 清楚明瞭。</p>

<p>Build 和 Run 都使用 <code>--rm</code> 來確保跑完以後就刪除，節省系統空間。當然如果有保留的需求，例如這個跑完以後自動 trigger 一個專門測 IE 的 selenium test target 的話這邊是可以不用刪除的，看個人需求。</p>

<p>Build 完以後也可以同時跑好幾個 containers，利用一個 image 可以跑很多 containers 的特性，例如把 spec 目錄分成幾區，同時開始跑測試，這樣平行處理可以節省時間。</p>

<p>這邊有一個問題就是 <code>docker run</code> 理論上要回傳 command 的 exit code 不過這部分常常出問題，<a href="https://github.com/dotcloud/docker/issues/6259">時好時壞</a> 所以這邊我決定自己來處理。</p>

<p>想法很簡單，直接把 <code>docker run</code> 的 output 拿來檢查，有偵測到爆炸的話就寫一個檔案，最後來檢查檔案，如果沒過就手動爆炸。等這個 bug 修復穩定之後，就可以不要使用這個 workaround 了。</p>

<p><code>``
docker run --rm project/$BUILD_NUMBER | perl -pe '/Failed examples:/ &amp;&amp;</code>echo &ldquo;fail&rdquo; > docker-tests-failed`&lsquo;
docker rmi project/$BUILD_NUMBER</p>

<p>if [ ! -f docker-tests-failed ]; then
  echo -e &ldquo;No docker-tests-failed file. Apparently tests passed.&rdquo;
else
  echo -e &ldquo;docker-tests-failed file found, so build failed.&rdquo;
  rm docker-tests-failed
  exit 1
fi
```</p>

<p>如果你沒有遇到這個問題，或者你是使用 <a href="https://github.com/sj26/rspec_junit_formatter">rspec_junit_formatter</a> 之類的套件產生 JUnit 檔案的話並加掛 Post-build action 的話，這個動作會讀 JUnit 檔案的內容來改變 Build result 因此也不需要這個 workaround.</p>

<h2>其他整合</h2>

<ul>
<li><p>Jenkins 有一個 plugin <a href="https://wiki.jenkins-ci.org/display/JENKINS/GitHub+pull+request+builder+plugin">Github Pull Request Builder</a> 可以讓 Jenkins 像 travis-ci 那類 service 在 Github 有人發 PR 時自動抓回來 Build。</p></li>
<li><p>Hipchat plugin 可以整合到公司通訊軟體。</p></li>
<li><p><a href="https://github.com/sj26/rspec_junit_formatter">rspec_junit_formatter</a> 可以把 rspec 的結果產生成 JUnit 的 xml 給 Jenkins 讀取。</p></li>
<li><p>Test Coverage 的部分我們則是使用 <a href="https://github.com/colszowka/simplecov">SimpleCov</a> 可以搭配 <a href="https://github.com/fguillen/simplecov-rcov">SimpleCov Rcov Formatter</a> 產生 Jenkins 可讀的報表。</p></li>
</ul>


<p>要使用以上這兩個套件，必須在測試跑完以後使用 <code>docker cp &lt;file&gt; .</code> 指令把報表複製回 workspace 讓 Jenkins 讀取。</p>

<h2>參考連結</h2>

<p>這邊列出一些不錯的連結：</p>

<ul>
<li><a href="http://www.tech-d.net/2014/02/06/docker-quicktip-3-onbuild/">Docker quicktip #3 – ONBUILD</a></li>
<li><a href="http://www.powpark.com/blog/programming/2014/01/29/integrating-docker-with-jenkins-for-ruby-on-rails-app">Integrating Docker with Jenkins for continuous deployment of a Ruby on Rails application</a></li>
<li><a href="http://www.activestate.com/blog/2014/01/using-docker-run-ruby-rspec-ci-jenkins">Using Docker To Run Ruby Rspec CI In Jenkins</a></li>
<li><a href="http://blog.gemnasium.com/post/66356385701/your-dockerfile-for-rails">Your Dockerfile for Rails</a></li>
<li><a href="http://ngauthier.com/2013/10/using-docker-to-parallelize-rails-tests.html">Using Docker to Parallelize Rails Tests</a></li>
<li><a href="https://zapier.com/engineering/continuous-integration-jenkins-docker-github/">How to Set Up TravisCI-like Continuous Integration with Docker and Jenkins</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
