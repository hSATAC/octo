<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: rails | hSATAC]]></title>
  <link href="http://blog.hsatac.net/categories/rails/atom.xml" rel="self"/>
  <link href="http://blog.hsatac.net/"/>
  <updated>2014-06-30T01:55:50+08:00</updated>
  <id>http://blog.hsatac.net/</id>
  <author>
    <name><![CDATA[Ash Wu]]></name>
    <email><![CDATA[hsatac@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[整合 Jenkins 和 Docker]]></title>
    <link href="http://blog.hsatac.net/2014/06/working-with-docker-and-jenkins/"/>
    <updated>2014-06-29T22:51:00+08:00</updated>
    <id>http://blog.hsatac.net/2014/06/working-with-docker-and-jenkins</id>
    <content type="html"><![CDATA[<p>這篇將會記述一些我自己整合 Jenkins CI 和 Docker 的思路、想法、要點以及備忘。不會有 step by step 的教學，若有此類需求請參考最後附錄。</p>

<h2>Why Docker?</h2>

<p>Jenkins 跑的好好的，為什麼要摻 Docker 呢？原本我們 Rails Rspec 跑的其實也不錯，但受限於 database 以及 elasticsearch, redis 等 services，無法同時跑多個 worker, 再加上未來若有平行化測試以及多個專案 / 不同 db 版本等等的需求，引入 docker 可以完美解決這些問題。</p>

<h2>Concept</h2>

<p>使用 Docker 的好處就是原本的 shell script 幾乎都不用改即可繼續使用，引入的門檻降到極低。</p>

<p>基本概念是建立一個可以跑 Rails app 起來的環境，然後把整個 CI 的 workspace 丟進去跑測試，其他的步驟都一模一樣。</p>

<p>在建立環境這邊基本上有兩個選擇，一種是全部包成一個 image, 就用這個 container 來跑測試。另一種是每個需要的 service 都是一個各自的 container, 彼此之間透過 <a href="https://docs.docker.com/userguide/dockerlinks/">Docker Container Linking</a> 來通訊，例如 postgresql 自己一個、elasticsearch 自己一個、rails 自己一個這樣。</p>

<p>不過由於跑測試都是用過即丟，這次我直接採用最簡單的包一大包的策略來進行，減少複雜度。</p>

<!--more-->


<h3>Base Image</h3>

<p>我的設計是先建立一個 base image 例如給他 tag 叫 <code>project/base</code> 裡面先預裝好了所有環境包括 pg, elasticsearch, redis, rvm, ruby 等等。</p>

<p>舉例來說可能長這樣：</p>

<p>```
FROM ubuntu:12.04
MAINTAINER hSATAC</p>

<h1>We use bash</h1>

<p>RUN rm /bin/sh &amp;&amp; ln -s /bin/bash /bin/sh</p>

<h1>We don&rsquo;t like apt-get warnings.</h1>

<p>ENV DEBIAN_FRONTEND noninteractive</p>

<h1>Add the PostgreSQL PGP key to verify their Debian packages.</h1>

<h1>It should be the same key as <a href="https://www.postgresql.org/media/keys/ACCC4CF8.asc">https://www.postgresql.org/media/keys/ACCC4CF8.asc</a></h1>

<p>RUN apt-key adv &mdash;keyserver keyserver.ubuntu.com &mdash;recv-keys B97B0AFCAA1A47F044F244A07FCC7D46ACCC4CF8</p>

<h1>Add PostgreSQL&rsquo;s repository. It contains the most recent stable release</h1>

<h1>of PostgreSQL, <code>9.3</code>.</h1>

<p>RUN echo &ldquo;deb <a href="http://apt.postgresql.org/pub/repos/apt/">http://apt.postgresql.org/pub/repos/apt/</a> precise-pgdg main&rdquo; > /etc/apt/sources.list.d/pgdg.list</p>

<h1>Update the Ubuntu and PostgreSQL repository indexes</h1>

<p>RUN apt-get update</p>

<h1>=== Locale ===</h1>

<p>RUN locale-gen  en_US.UTF-8
ENV LANG en_US.UTF-8
ENV LANGUAGE en_US.UTF-8
ENV LC_ALL en_US.UTF-8</p>

<h1>=== Requirements ===</h1>

<p>RUN apt-get -y -q install nodejs libpq-dev wget git curl imagemagick vim postfix</p>

<p>RUN cd /tmp &amp;&amp;\</p>

<pre><code>wget http://downloads.sourceforge.net/project/wkhtmltopdf/0.12.0/wkhtmltox-linux-amd64_0.12.0-03c001d.tar.xz &amp;&amp;\
tar Jxvf wkhtmltox-linux-amd64_0.12.0-03c001d.tar.xz &amp;&amp;\
cd wkhtmltox &amp;&amp;\
install bin/wkhtmltoimage /usr/bin/wkhtmltoimage
</code></pre>

<h1>=== Redis ===</h1>

<p>RUN apt-get -y -q install redis-server</p>

<h1>=== Elasticsearch ===</h1>

<p>RUN apt-get install openjdk-7-jre-headless -y -q
RUN wget <a href="https://download.elasticsearch.org/elasticsearch/elasticsearch/elasticsearch-1.1.0.deb">https://download.elasticsearch.org/elasticsearch/elasticsearch/elasticsearch-1.1.0.deb</a>
RUN dpkg -i elasticsearch-1.1.0.deb</p>

<h1>=== RVM ===</h1>

<p>RUN curl -L <a href="https://get.rvm.io">https://get.rvm.io</a> | bash -s stable
ENV PATH /usr/local/rvm/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
RUN /bin/bash -l -c rvm requirements
RUN source /usr/local/rvm/scripts/rvm &amp;&amp; rvm install ruby-2.1.2
RUN rvm all do gem install bundler</p>

<h1>=== Postgresql ===</h1>

<p>RUN apt-get -y -q install python-software-properties software-properties-common
RUN apt-get -y -q install postgresql-9.3 postgresql-client-9.3 postgresql-contrib-9.3</p>

<h1>Update template1 to enable UTF-8 and hstore</h1>

<p>USER postgres
RUN    /etc/init.d/postgresql start &amp;&amp;\</p>

<pre><code>psql -c "update pg_database set datistemplate=false where datname='template1';" &amp;&amp;\
psql -c 'drop database Template1;' &amp;&amp;\
psql -c "create database template1 with owner=postgres encoding='UTF-8' lc_collate='en_US.utf8' lc_ctype='en_US.utf8' template template0;" &amp;&amp;\
psql -c 'CREATE EXTENSION hstore;' -d template1
</code></pre>

<h1>Create a PostgreSQL role and db</h1>

<p>RUN    /etc/init.d/postgresql start &amp;&amp;\</p>

<pre><code>psql --command "CREATE ROLE jenkins LOGIN PASSWORD 'jenkins' SUPERUSER INHERIT CREATEDB NOCREATEROLE NOREPLICATION;" &amp;&amp;\
createdb -O jenkins jenkins_test &amp;&amp;\
createdb -O jenkins jenkins_production
</code></pre>

<h1>Adjust PostgreSQL configuration</h1>

<p>RUN echo &ldquo;local all  all  md5&rdquo; > /etc/postgresql/9.3/main/pg_hba.conf</p>

<h1>And add <code>listen_addresses</code> to <code>/etc/postgresql/9.3/main/postgresql.conf</code></h1>

<p>RUN echo &ldquo;listen_addresses=&lsquo;*&rsquo;&rdquo; >> /etc/postgresql/9.3/main/postgresql.conf
```</p>

<h3>Test Image</h3>

<p>接著用 <code>project/base</code> build 一個 <code>project/test</code>，這個 image 會安裝一些「只有測試會用到」的套件，順便把 Gemfile 複製進去安裝一下 Gem, 這樣到時在跑測試的時候就可以省略 <code>bundle install</code> 的時間了。因為我的 base image 還有打算拿來做其他用途，所以這邊是這樣設計。</p>

<p>每天凌晨三點左右用 crontab 重新 Build 一次這個 <code>project/test</code> 的 image 以更新 gems. 當然這邊牽涉到一些如何同步你專案中的 Gemfile 不過這都是簡單的 script 可以解決的問題，這邊不贅述。</p>

<p>```
FROM project/base</p>

<h1>Switch back to root</h1>

<p>USER root</p>

<h1>Set ENV</h1>

<p>ENV RAILS_ENV test</p>

<h1>Preinstall gem</h1>

<p>ADD gem /opt/project_gem # 這個 gem 目錄裡面有 Gemfile 和 Gemfile.lock
WORKDIR /opt/project_gem
RUN rvm all do bundle install</p>

<h1>Install Firefox &amp; Xvfb</h1>

<p>RUN apt-get -y install firefox xvfb # 跑 selenium test 用的</p>

<h1>Onbuild witch back to root</h1>

<p>ONBUILD USER root</p>

<h1>Mound Rails directory</h1>

<p>ONBUILD ADD . /opt/project
ONBUILD WORKDIR /opt/project</p>

<h1>Bundle install</h1>

<p>ONBUILD RUN rvm all do bundle install</p>

<h1>Go</h1>

<p>ONBUILD ADD start_services.sh /opt/project/start_services.sh
ONBUILD RUN chmod +x /opt/project/start_services.sh
ONBUILD ADD run_tests.sh /opt/project/run_tests.sh
ONBUILD RUN chmod +x /opt/project/run_tests.sh
ONBUILD CMD /opt/project/start_services.sh &amp;&amp; /opt/project/run_tests.sh
```</p>

<p>注意這邊最後一段用到了上一篇文章 <a href="/2014/06/docker-basics/">Docker Basics</a> 中所講到的 ONBUILD, 使用這個功能我們就可以很輕鬆的 build 出真正用來測試的 Image.</p>

<p>這幾行實際做的動作是複製兩個 scripts 分別名叫 <code>start_services.sh</code> 和 <code>run_tests.sh</code> 並且 <code>CMD</code> 預設執行這兩個檔案。</p>

<p>但是這兩個檔案現在實際不存在，我會透過 jenkins 的 build scripts 來寫這兩個檔案，其實也就是原本在 build scripts 的內容移到這兩個檔案中了。之所以不把這兩個檔案存在某處再複製過來，就是想保留原本在 Jenkins configure 可以調整 Build Script 的機制，多留一點彈性。</p>

<p>為什麼要這麼麻煩使用 ONBUILD + CMD ，而不是直接 RUN 然後最後直接看 Image 有沒有建置成功就好？除了上述想多留一點彈性的原因外，還有用 Build 這樣 Build 的過程勢必會跑這兩支 script, 而我有可能 Build 完以後不跑這兩支 script, 而是做一些其他的動作例如 <code>/bin/bash</code> 進去 debug 等等，當然可以透過改寫這兩支 script 的內容來使 Build 過程不跑測試，但增添了複雜度。使用這個機制我覺得是最有彈性的。</p>

<h3>Jenkins Build Script</h3>

<p>Jenkins build script 這邊改動的幅度不大，原本的流程大概是：</p>

<ol>
<li><p>改好相關 application.yml, database.yml 等等 local 設定檔並塞進去。</p></li>
<li><p>跑 db:reset 等等重置環境</p></li>
<li><p>跑測試</p></li>
</ol>


<p>基本步驟還是一樣，第一步可以完全不用變，後面就得修改一下，例如：</p>

<p>```</p>

<h1>Start services in docker</h1>

<p>echo &ldquo;
Xvfb :99 -screen 0 1366x768x24 -ac 2>/dev/null >/dev/null &amp;
/etc/init.d/postgresql start &amp;&amp;\
/etc/init.d/redis-server start &amp;&amp;\
/etc/init.d/elasticsearch start
&rdquo; > start_services.sh</p>

<h1>Run tests</h1>

<p>echo &ldquo;
rvm all do bundle exec rake db:migrate &amp;&amp;\
DISPLAY=:99 rvm all do bundle exec rspec spec &mdash;format=documentation
&rdquo; > run_tests.sh</p>

<p>echo &ldquo;FROM project/test&rdquo; > Dockerfile
docker build &mdash;rm -t project/$BUILD_NUMBER .
docker run &mdash;rm project/$BUILD_NUMBER
```</p>

<p>一開始用 echo 寫入兩個檔案，內容大致就是開啟 service 並且開始跑測試，值得注意的是我們在 Jenkins workspace 裡寫了一個新的 Dockerfile, 裡面只有一行內容 <code>FROM project/test</code> 配合之前的 <code>ONBUILD</code> 就可以建置出這個 image. 之所以不直接用 <code>&lt;</code> 的方式把內容丟到 <code>docker build</code> 指令，是因為 <code>ADD</code> 需要 context, 也就是 Jenkins workspace, 所以必須要寫實體的檔案出來。</p>

<p>Image tag 直接取用 Jenkins 的環境變數 <code>$BUILD_NUMBER</code> 因此像第 300 個 build 他的 image 就會叫 <code>project/300</code> 清楚明瞭。</p>

<p>Build 和 Run 都使用 <code>--rm</code> 來確保跑完以後就刪除，節省系統空間。當然如果有保留的需求，例如這個跑完以後自動 trigger 一個專門測 IE 的 selenium test target 的話這邊是可以不用刪除的，看個人需求。</p>

<p>Build 完以後也可以同時跑好幾個 containers，利用一個 image 可以跑很多 containers 的特性，例如把 spec 目錄分成幾區，同時開始跑測試，這樣平行處理可以節省時間。</p>

<p>這邊有一個問題就是 <code>docker run</code> 理論上要回傳 command 的 exit code 不過這部分常常出問題，<a href="https://github.com/dotcloud/docker/issues/6259">時好時壞</a> 所以這邊我決定自己來處理。</p>

<p>想法很簡單，直接把 <code>docker run</code> 的 output 拿來檢查，有偵測到爆炸的話就寫一個檔案，最後來檢查檔案，如果沒過就手動爆炸。等這個 bug 修復穩定之後，就可以不要使用這個 workaround 了。</p>

<p><code>``
docker run --rm project/$BUILD_NUMBER | perl -pe '/Failed examples:/ &amp;&amp;</code>echo &ldquo;fail&rdquo; > docker-tests-failed`&lsquo;
docker rmi project/$BUILD_NUMBER</p>

<p>if [ ! -f docker-tests-failed ]; then
  echo -e &ldquo;No docker-tests-failed file. Apparently tests passed.&rdquo;
else
  echo -e &ldquo;docker-tests-failed file found, so build failed.&rdquo;
  rm docker-tests-failed
  exit 1
fi
```</p>

<h2>其他整合</h2>

<p>Jenkins 有一個 plugin <a href="https://wiki.jenkins-ci.org/display/JENKINS/GitHub+pull+request+builder+plugin">Github Pull Request Builder</a> 可以讓 Jenkins 像 travis-ci 那類 service 在 Github 有人發 PR 時自動抓回來 Build。</p>

<p>另外也有 hipchat plugin 可以整合到公司通訊軟體，這部分和主題相關薄弱就不多談了。</p>

<h2>參考連結</h2>

<p>這邊列出一些不錯的連結：</p>

<ul>
<li><a href="http://www.tech-d.net/2014/02/06/docker-quicktip-3-onbuild/">Docker quicktip #3 – ONBUILD</a></li>
<li><a href="http://www.powpark.com/blog/programming/2014/01/29/integrating-docker-with-jenkins-for-ruby-on-rails-app">Integrating Docker with Jenkins for continuous deployment of a Ruby on Rails application</a></li>
<li><a href="http://www.activestate.com/blog/2014/01/using-docker-run-ruby-rspec-ci-jenkins">Using Docker To Run Ruby Rspec CI In Jenkins</a></li>
<li><a href="http://blog.gemnasium.com/post/66356385701/your-dockerfile-for-rails">Your Dockerfile for Rails</a></li>
<li><a href="http://ngauthier.com/2013/10/using-docker-to-parallelize-rails-tests.html">Using Docker to Parallelize Rails Tests</a></li>
<li><a href="https://zapier.com/engineering/continuous-integration-jenkins-docker-github/">How to Set Up TravisCI-like Continuous Integration with Docker and Jenkins</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails i18n Relative Key in Controller Before Action]]></title>
    <link href="http://blog.hsatac.net/2014/04/rails-i18n-relative-key-in-controller-before-action/"/>
    <updated>2014-04-12T04:42:00+08:00</updated>
    <id>http://blog.hsatac.net/2014/04/rails-i18n-relative-key-in-controller-before-action</id>
    <content type="html"><![CDATA[<p>在 Rails i18n 裡面可以用 relative path 像 <code>t('.key')</code> 這樣的 shortcut，不過這個 shortcut 吃得是 <code>"#{ controller_path.tr('/', '.') }.#{ action_name }#{ key }"</code>。</p>

<p>今天碰到 controller 的 before action 裡面用 relative path 結果 locale yml 編到 before action 的 key，但真正會去 lookup 的是 <code>action_name</code> 而不是 before action 的 method name 所以就爆 missing 了。</p>

<p>萬一這個 before_action 之後多加幾個其他的 action 的話很容易就沒改到 locale yml 而爆錯誤，為了保險起見決定把他們都改成 absolute key path. 不過 controller 檔案非常多，所以要寫一隻程式把所有 before action 裡面有用到 relative path 的 t 撈出來。</p>

<p>一開始的想法是用 regex 速解，不過因為 controller 裡面的 t 還滿多的，然後我又很難判斷 before action method 的 scope，於是念頭一轉就直接改用 <a href="https://github.com/whitequark/parser">Ruby Parser</a> 來做。</p>

<p>直接把 controller 檔案都讀進來，拿 AST 來抓 before actions，再去檢查這些 before action 是否有 call 到 relative keypath 的 t。用起來還滿方便的，效率也不差，一下子就寫完了。</p>

<p>程式碼放在 <a href="https://github.com/hSATAC/parse-relative-key">Github</a>，不過這麼特定目的東西應該是無法重用，放著以後有需要的時候回來看一下。</p>

<p>最後就是&hellip;i18n 沒事還是不要用 relative key 比較好&hellip;散在 controller, helper, service 裡面到時要搬移 code 或者作 refactor 的時候就麻煩了。動態語言重構不像靜態語言這麼便利啊&hellip;。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xray-rails 與 tmux, vim 整合]]></title>
    <link href="http://blog.hsatac.net/2013/07/xray-rails-tmux-vim-integration/"/>
    <updated>2013-07-09T22:00:00+08:00</updated>
    <id>http://blog.hsatac.net/2013/07/xray-rails-tmux-vim-integration</id>
    <content type="html"><![CDATA[<p>剛好又開新專案了，來介紹一下 <a href="https://github.com/brentd/xray-rails">Xray-rails</a> 與 tmux, vim 的整合。</p>

<p><a href="https://github.com/brentd/xray-rails">Xray-rails</a> 是一層 rack middleware，會 inject 你的 view 和 javascript 檔案，只要在開發模式按快速鍵 <code>⌘ + ⇧ + x</code> 就會開啟一層 overlay，讓你很清楚的看出現在的畫面由哪些 view, partial, controller 生成，更方便的是只要一點畫面，即可在編輯器中開啟該檔案，大大降低 trace 程式碼的時間。</p>

<p><img src="https://dl.dropboxusercontent.com/u/156655/xray-screenshot.png" alt="Xray-rails" /></p>

<!--more-->


<p><a href="https://github.com/brentd/xray-rails">Xray-rails</a> 預設的編輯器是 <a href="http://www.sublimetext.com/2">Sublime Text 2</a> (<code>/usr/local/bin/subl</code>)。可以透過 overlay 右下角的設定圖示、或者自己新增 <code>~/.xrayconfig</code> 檔案來設定你使用的編輯器。</p>

<p>我平常使用 <a href="https://github.com/aziz/tmuxinator">Tmuxinator</a> 來管理我的專案和 tmux, 每個專案有自己的 tmux session，讓我可以快速在不同專案的開發環境之間切換。</p>

<p>我的 <code>~/.xrayconfig</code> 也改成透過 tmux 傳送指令給我的 vim，範例設定檔如下：</p>

<p><code>
:editor: "/usr/local/bin/tmux send -t openapply:editor ESCAPE :tabe $file ENTER"
</code></p>

<p><code>openapply</code> 是我的專案 tmux session 名稱，而 <code>editor</code> 是該 session 的 window 名稱，專門用來開啟 vim 編輯檔案。</p>

<p>但問題來了，我每一個專案都有自己獨立的 tmux session，這樣每次切換專案的時候我都要修改 <code>~/.xrayconfig</code> 實在很不方便，所以希望能在每一個專案底下放自己的 <code>.xrayconfig</code>。</p>

<p><p class='info info' data-title='Update 2013/08/14'>這個 Pull request 已被 upstream 收下，可以直接使用官方 git repo。</p></p>

<p>這個功能已經<a href="https://github.com/brentd/xray-rails/issues/21">提案給原作者同意</a>，也送了 <a href="https://github.com/brentd/xray-rails/pull/23">pull request</a>，不過還沒被 merge 回主幹，如果現在有需要這個功能的朋友可以暫時先使用我修改的 fork。</p>

<p>```
  gem &lsquo;xray-rails&rsquo;, :git => &lsquo;<a href="https://github.com/hSATAC/xray-rails.git">https://github.com/hSATAC/xray-rails.git</a>&rsquo;,</p>

<pre><code>                :branch =&gt; 'feature/project_specific_config'
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TDD Rails]]></title>
    <link href="http://blog.hsatac.net/2013/05/tdd-rails/"/>
    <updated>2013-05-19T19:23:00+08:00</updated>
    <id>http://blog.hsatac.net/2013/05/tdd-rails</id>
    <content type="html"><![CDATA[<p>這兩個月到新公司學到了不少東西，對於「寫測試」這件事也有了新的想法。先感謝最近一直和我 pair 的 @ilake，許多觀念和工具都是他帶給我的。</p>

<p>還記得幾年前剛聽到「測試」、「TDD」這些名詞的時候，那時我去 Ruby Tuesday 碰到人就會問一下：「你有在寫測試嗎？」@ihower 跟 @xdite 應該都被我問過這個問題。那時雖然知道寫測試的好處，也大概試過 TDD 的手法，不過總感覺搔不到癢處；再加上那時待的公司也都沒有這個環境，就放置 Play 了。</p>

<p>一直到跟 @ilake pair 過後才知道，問題不在「要不要寫測試」、而是「測試該怎麼寫」。</p>

<!-- more -->


<h3>Why TDD? Why Not?</h3>

<p>我們一般對寫測試和 TDD 會有以下的迷思：</p>

<ul>
<li>TDD 違反人類思考的習慣</li>
<li>寫測試會比較耗時間</li>
<li>沒牽涉到金流等重大功能不需要寫測試</li>
</ul>


<p>先講第一點，<strong>TDD 違反人類思考的習慣？</strong>：其實我們平常寫程式的行為，本來就是寫一點點、然後切過去執行看看、再寫一點點、再切過去執行看看&hellip;&hellip;重複這個循環。</p>

<p>這跟 TDD 的開發模式基本上是一樣的，差別只在於先把想要的結果寫好而已。而且這樣的方式可以強迫你用比較好測試的方式去組織你的程式碼，也就是說你的 code 天生架構就會比較好。</p>

<p><strong>寫測試會比較耗時間嗎？</strong>這邊應該分成整體開發時間和單元開發時間來看。先說整體開發時間，有寫測試可以讓整個 team 都放心改 code ，減低踩雷的機會。與其寫一寫發現之前寫的東西爆炸了再回頭修改，寫測試反而能降低整體開發的時間。</p>

<p>那單元測試時間呢？TDD 寫的 code 比較多，理論上應該會增加單元開發時間，不過只要使用對的工具和 work flow，其實單元開發時間不會增加多少，甚至還有可能更快。開發 Rails 可能寫一寫就要切到瀏覽器看一下行為，但是使用 TDD 我們可以一鍵直接測到我們想測的部份，不用花時間在切換、等待上面。等到整個 feature 開發完成再去瀏覽器做最後確認就好，反而增加了開發效率。</p>

<p><strong>沒牽涉到金流等重大功能不需要寫測試？</strong>：當你享受過 TDD 帶來的好處時其實就不會再有這樣的想法了，不過寫測試的確還有其他的優點。我到 Faria 第一天就能直接上工解 issue 就是因為有測試當我的後盾。測試本身也就是 spec ，能清楚定義你程式的行為。碰到有 bug 的時候就直接寫一個這個 bug 的測試，修到他過了，以後就再也不會碰到那種「咦，這個 bug 不是我以前解過了嗎？怎麼又跑出來了？」的狀況。</p>

<h3>Work Flow</h3>

<p>前面說到只要使用對的工具和 work flow，就能享受到 TDD 的快感。相關的工具和 library 非常多，這邊直接講兩個重點：</p>

<ol>
<li>快速執行測試以及觀看測試結果(一鍵執行)</li>
<li>跑測試本身的速度要快</li>
</ol>


<p>前陣子使用 Sublime Text 2 時，搭配 <a href="https://github.com/maltize/sublime-text-2-ruby-tests">Sublime Text 2 Ruby Tests</a> 這個 plugin，只要按 <code>cmd + shift + r</code> 就可以直接跑當前游標所在測試 <code>cmd + shift + t</code> 跑整個檔案 <code>cmd + shift + e</code> 跑上一次執行的測試。</p>

<p>最近改回 vim 環境則是使用 @ilake 推薦的 <a href="https://github.com/jgdavey/vim-turbux">turbux</a> 和 <a href="https://github.com/jgdavey/tslime.vim">tslime</a> 一樣一鍵執行測試，並送到你選擇的 tmux windows 去執行。詳細的設定可以參考<a href="https://github.com/hSATAC/vimrc">我的 vimrc</a>。</p>

<p>至於跑測試本身的速度要快這點，由於 Rails 環境要 boot 起來其實花的時間真的挺久的，可以使用 <a href="https://github.com/burke/zeus">Zeus</a> 或 <a href="https://github.com/jonleighton/spring">Spring</a> 來加速。</p>

<p>其實以上這兩點都是為了一個目的，就是要「快速拿到你的 feedback」。當你有了這個環境，你寫好測試你就只要一直去 run 他 run 到你的實作通過測試為止。絕對比寫一寫切到瀏覽器看一下來的快速可靠。</p>

<h3>結語</h3>

<p>寫測試的好處真的百百種，說都說不完，而且現在寫測試應該也算是 programmer 的必備技能了。前陣子我發給 <a href="https://github.com/mroth/lolcommits">lolcommits</a> 的 pull request 也被要求補測試才收我的 patch。可預見不遠的將來，甚至是現在，寫測試將會是軟體開發中不可或缺的一個環節。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[整合 Redmine 和 git]]></title>
    <link href="http://blog.hsatac.net/2011/04/redmine-git-integration/"/>
    <updated>2011-04-14T00:00:00+08:00</updated>
    <id>http://blog.hsatac.net/2011/04/redmine-git-integration</id>
    <content type="html"><![CDATA[<p>其實就是[專案設定] > [版本控管] 裡面填 git repo path 而已<br />
不過一直報找不到專案，看了一下 error log  原來是找不到 git 執行檔<br />
解法很簡單，原本 httpd.conf 設定的 ruby 要再包一層去 export path<br />
例如原本你設定的是
<pre lang="bash">
PassengerRuby /usr/local/Cellar/ruby-enterprise-edition/2011.03/bin/ruby
</pre></p>




<p>就開一個  /usr/local/bin/ruby_with_env 的可執行檔<br />
裡面把 export $PATH
<pre lang="bash">
#!/bin/bash
export PATH="/usr/local/bin:/usr/local/sbin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/X11/bin:/opt/local/bin:/usr/local/git/bin:/usr/local/git/bin/:$PATH"
/usr/local/Cellar/ruby-enterprise-edition/2011.03/bin/ruby $*
</pre></p>




<p>再把 httpd.conf 的裡面設定的 ruby 改成
<pre lang="bash">
PassengerRuby /usr/local/bin/ruby_with_env
</pre></p>




<p>大功告成！</p>

]]></content>
  </entry>
  
</feed>
