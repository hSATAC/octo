<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: git | hSATAC]]></title>
  <link href="http://blog.hsatac.net/categories/git/atom.xml" rel="self"/>
  <link href="http://blog.hsatac.net/"/>
  <updated>2014-04-12T05:03:00+08:00</updated>
  <id>http://blog.hsatac.net/</id>
  <author>
    <name><![CDATA[Ash Wu]]></name>
    <email><![CDATA[hsatac@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[用 Commandline 發 github pull request]]></title>
    <link href="http://blog.hsatac.net/2013/07/github-pull-request-from-commandline/"/>
    <updated>2013-07-16T12:40:00+08:00</updated>
    <id>http://blog.hsatac.net/2013/07/github-pull-request-from-commandline</id>
    <content type="html"><![CDATA[<p>現在團隊使用 github 來作 code hosting, 利用 pull request 機制來做 code review。比以往自己架 gitosis 和 redmine 的方式更方便好用。</p>

<p>不過 programmer 天性懶惰，日子一久對於要開 github 網頁用滑鼠選 branch 發 pull request 的操作感到厭倦，能自動化的東西就懶得自己按按鈕啦！</p>

<p>使用 <a href="https://github.com/github/hub">hub</a> 就可以用 commandline 進行各種 github 的操作。</p>

<!--more-->


<p>用 <code>homebrew</code> 或 <code>gem</code> 都可以進行安裝。</p>

<p><code>
brew install hub
gem install hub
</code></p>

<p>我們 team 開發流程是 feature branch 開發完畢後 push 到專案 remote 發 pull request，所以我在 <code>.bash_profile</code> 加了下面這個 function：</p>

<p><div><script src='https://gist.github.com/5591270.js'></script>
<noscript><pre><code></code></pre></noscript></div>
</p>

<blockquote><p>從 team 的 (現在目錄所在 branch) 發 pull request 到 team 的 (develop) branch</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[同步 git 和 hg 的 repository]]></title>
    <link href="http://blog.hsatac.net/2012/10/sync-git-with-hg/"/>
    <updated>2012-10-17T10:20:00+08:00</updated>
    <id>http://blog.hsatac.net/2012/10/sync-git-with-hg</id>
    <content type="html"><![CDATA[<p>最近在玩 go，編輯器主要是使用 vim 搭配 <a href="https://github.com/nsf/gocode">gocode</a>。我習慣用 <a href="https://github.com/tpope/vim-pathogen">pathogen.vim</a> 來管理我的 vim 套件，不過 go 官方附的 vim syntax plugin 和 gocode 提供的 autocompletion plugin 目錄結構都無法直接當成 git submodule 引入我的 vim 設定中。</p>

<p>由於我個人潔癖作祟，不想再用 copy 的方式來管理我的 vim plugins，所以我決定自己把這兩份 plugin 抽出來獨立成各自的 git repositories，就可以當成 git submodule 引用了。</p>

<!--more-->


<p>gocode 的部分很容易，他原本就是 git，只要參考我之前的文章「<a href="http://blog.hsatac.net/2012/04/moving-files-from-one-git-repository-to-another-keeping-commit-history/">把 Git 中的目錄搬到另一個 Git 並保留 Commit</a>」就可以了。不過 go 的部分就沒這麼簡單了。go 的原始碼 host 在 google code 上，採用 hg，因此要想辦法先把他由 hg 轉換成 git 才行。</p>

<p>一開始使用的是 <a href="http://hg-git.github.com/">hg-git</a> 這套，不過在 gexport 這個過程非常緩慢，不知道是這個套件本身有問題還是 go 的 hg repository 太大了。試了兩天之後只好放棄，改用 <a href="http://offbytwo.com/git-hg/">git-hg</a> 這套。這套一樣也是使用 python 寫的，不過效率上就挺不錯的。使用上也很方便，直接 <code>git-hg clone https://code.google.com/p/go/</code> 出來就是 git 的目錄了。</p>

<p>值得一提的是，使用 homebrew 安裝 git-hg 時，由於 git-hg 有 require <a href="http://repo.or.cz/w/fast-export.git">fast-export</a> 這個 submodule，但 homebrew 安裝下來的 fast-export 居然不是最新的，導致無法使用。後來自己到 <code>/usr/local/Cellar/git-hg/HEAD</code> 把 fast-export 這個目錄移除，再 clone 一份新的 fast-export 就可以正常使用了。</p>

<p>我不想弄亂這個目錄，所以我是在 local 端再 clone 一次這個使用 git-hg clone 下來的 repository，再來作 <code>git filter-branch</code> 的動作。另外這個 repository 也順便丟到 github 上當作一個 go 的 git mirror 給有需要的人使用。</p>

<p>產出三個 repositories:</p>

<ul>
<li><p><a href="https://github.com/golangtw/go.vim">https://github.com/golangtw/go.vim</a> go 的 syntax plugin</p></li>
<li><p><a href="https://github.com/golangtw/gocode.vim">https://github.com/golangtw/gocode.vim</a> gocode 的 autocomplete plugin</p></li>
<li><p><a href="https://github.com/golangtw/go">https://github.com/golangtw/go</a> go 的 git mirror</p></li>
</ul>


<p>最後再寫一個 script 每天跑一次 cronjob 自動去 sync 就完成啦！</p>

<p><div><script src='https://gist.github.com/3903435.js'></script>
<noscript><pre><code>#!/bin/sh

# do gocode first
cd /Users/cat/golang.tw/gocode
git pull
git filter-branch -f --subdirectory-filter vim -- --all
git push pathogen master
git fetch
git reset --hard origin/master

# do git-hg sync go
cd /Users/cat/golang.tw/go.git
git-hg pull
git push origin master

# do go.vim

cd /Users/cat/golang.tw/go.vim
git pull
git filter-branch -f --subdirectory-filter misc/vim -- --all
git push github master
git fetch
git reset --hard origin/master
</code></pre></noscript></div>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自動檢查 git branch 是否 merge 過]]></title>
    <link href="http://blog.hsatac.net/2012/08/git-branching-model-regular-check/"/>
    <updated>2012-08-12T12:28:00+08:00</updated>
    <id>http://blog.hsatac.net/2012/08/git-branching-model-regular-check</id>
    <content type="html"><![CDATA[<p>按照一般 <a href="http://nvie.com/posts/a-successful-git-branching-model/">Git branching model</a> 來開發，當團隊人數稍多時，管理 Git branch 會變得有些麻煩。Branch 數量多之外，也很難記得哪些 branches 是已經 merge 進主幹、不再需要可以刪除；或者哪些 branches 沒有 merge 進主幹但已經放棄不用。這時就需要一些自動化的 script 幫助管理。</p>

<!--more-->


<p>本來是想全部用 bash 寫，不過功力不夠，最後還是偷懶用 ruby 了。</p>

<p>這個 script 會先檢查哪些 branches 已經 merge 過，如果沒有特殊理由就可以刪除了。也可以把刪除的動作寫在 script 讓他自動化，不過我這邊選擇保留一些手動的彈性。</p>

<p>再來是檢查哪些 branches 已經開很久了(開超過一個月)，卻又沒有 merge 進主幹，這時管理者可以看一下這些 branches 是否已經不再使用，可以刪除。</p>

<p><div><script src='https://gist.github.com/3246217.js'></script>
<noscript><pre><code>#!/usr/bin/env ruby
require 'rubygems'
require 'active_support'

merged = `cd /home/m/git/repositories/miiicasa.git &amp;&amp; git branch --merged master | grep -v master`
not_merged_cmd = 'cd /home/m/git/repositories/miiicasa.git &amp;&amp; git branch | grep -v master | grep -v support | grep -v qa'
for line in merged.split(&quot;\n&quot;)
  not_merged_cmd += '| grep -v ' + line
end
puts &quot;This is a regular check of miiiCasa.git branches\n&quot;
puts &quot;List below are branches already been merged into [master]:&quot;
puts &quot;Please check if they are still needed, grb delete them otherwise.\n&quot;
puts merged

puts &quot;\n--------------------\n\n&quot;

puts 'List below are branches order than 1 month and have NOT been merged into [master]:'
puts &quot;Please check if they are abandoned or forgotten.&quot;
not_merged = `#{not_merged_cmd}`
for line in not_merged
  date =  /\S+_([0-9]+)_/.match(line)[1]
  puts line if 1.month.ago &gt; Date.parse(date)
end</code></pre></noscript></div>
</p>

<p>我們團隊對於 branch 命名有規定，中間一定是八位數字的日期，例如 feature_20120812_sthcool 以便分辨這個 branch 的開創時間。如果沒有這樣的命名規定的話，也可以透過下面這樣的 script 來找出最後 active 的時間。</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for k in &lt;code>git branch|perl -pe s/^..//&lt;/code>;do echo -e &lt;code>git show --pretty=format:"%Cgreen%ci %Cblue%cr%Creset" $k|head -n 1&lt;/code>\t$k;done|sort -r</span></code></pre></td></tr></table></div></figure></notextile></div></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git 救回已刪除的檔案]]></title>
    <link href="http://blog.hsatac.net/2012/07/git-restore-removed-files/"/>
    <updated>2012-07-28T20:30:00+08:00</updated>
    <id>http://blog.hsatac.net/2012/07/git-restore-removed-files</id>
    <content type="html"><![CDATA[<p>在 Git 操作的過程中，有些檔案是無法用 git checkout 救回來的。這些稱之為 unreachable files 。例如你 git add 了，但還沒 commit 就 pull ，這時這些檔案會被刪除，但因為沒有 commit 所以無法用 reset 救回。並且在 git reflog 裡面也不會有紀錄。</p>

<p>還好 Git 非常萬能，可以使用 <code>git fsck --cache --unreachable</code> 會列出一堆檔案的 bash ，再使用 <code>git show &lt;hash&gt;</code> 逐一檢視檔案內容即可救回失去的檔案。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[把 Git 中的目錄搬到另一個 Git 並保留 commit]]></title>
    <link href="http://blog.hsatac.net/2012/04/moving-files-from-one-git-repository-to-another-keeping-commit-history/"/>
    <updated>2012-04-03T21:43:00+08:00</updated>
    <id>http://blog.hsatac.net/2012/04/moving-files-from-one-git-repository-to-another-keeping-commit-history</id>
    <content type="html"><![CDATA[<p>今天在 refactor 公司的 git repository 時，有個需求，是要把原本 A repository 的其中一個目錄抽出來，獨立成 B repository。</p>

<p>原本以為這個需求無法達成，不過做了點研究以後發現是可行的，甚至 B repository 是已存在的 repository 也可以做到！</p>

<p>先說獨立出新的 repository 這個狀況，很簡單，先 git clone 出一個乾淨的 A repository 然後 <code>git remote rm origin</code> 不要 track remote。</p>

<p>接著在 git 根目錄下 <code>git filter-branch --subdirectory-filter &lt;目錄&gt; -- --all</code> 你就會看到這個目錄以外的東西都不見了，而且相關的 commit log 還在。</p>

<p>如果是要獨立出一個新的 repository 做到這邊就可以結束了。</p>

<p>接著講要把檔案和 commit log 匯到已存在的 B repository：接續上一步，用 <code>mkdir &lt;你要的目錄&gt;; mv * &lt;你要的目錄&gt;</code> 把抽出來的檔案都移到你預想要放的目錄 <code>git add .; git commit</code> 後 <code>cd ..</code> 再用 git clone 把 B repository clone 出來，切到 B repository 的目錄，用 add local repository as remote 的方式 <code>git remote add repoA ../&lt;A repo 的目錄&gt;</code> 然後 <code>git pull repoA master</code> 就完成了。</p>

<p>參考：<a href="http://gbayer.com/development/moving-files-from-one-git-repository-to-another-preserving-history/">Moving Files from one Git Repository to Another, Preserving History</a></p>
]]></content>
  </entry>
  
</feed>
